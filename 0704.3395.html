<!DOCTYPE html><html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>[0704.3395] General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010.</title><meta property="og:description" content="This article presents a model of general-purpose computing on a semantic network substrate. The concepts presented are applicable to any semantic network representation. However, due to the standards and technological …">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010.">
<meta name="twitter:image:src" content="https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png">
<meta name="twitter:image:alt" content="ar5iv logo">
<meta property="og:title" content="General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010.">
<meta property="og:site_name" content="ar5iv">
<meta property="og:image" content="https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ar5iv.labs.arxiv.org/html/0704.3395">

<!--Generated on Tue Mar 19 20:44:35 2024 by LaTeXML (version 0.8.8) http://dlmf.nist.gov/LaTeXML/.-->
<!--Document created on original: April 16, 2007 revision: October 7, 2007.-->
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="keywords" lang="en" content="Fhat, RVM, XSD">

<script>
  function detectColorScheme(){
    var theme="light";
    var current_theme = localStorage.getItem("ar5iv_theme");
    if(current_theme){
      if(current_theme == "dark"){
        theme = "dark";
      } }
    else if(!window.matchMedia) { return false; }
    else if(window.matchMedia("(prefers-color-scheme: dark)").matches) {
      theme = "dark"; }
    if (theme=="dark") {
      document.documentElement.setAttribute("data-theme", "dark");
    } else {
      document.documentElement.setAttribute("data-theme", "light"); } }

  detectColorScheme();

  function toggleColorScheme(){
    var current_theme = localStorage.getItem("ar5iv_theme");
    if (current_theme) {
      if (current_theme == "light") {
        localStorage.setItem("ar5iv_theme", "dark"); }
      else {
        localStorage.setItem("ar5iv_theme", "light"); } }
    else {
        localStorage.setItem("ar5iv_theme", "dark"); }
    detectColorScheme(); }
</script>
<link media="all" rel="stylesheet" href="/assets/ar5iv-fonts.0.7.9.min.css"><link media="all" rel="stylesheet" href="/assets/ar5iv.0.7.9.min.css"><link media="all" rel="stylesheet" href="/assets/ar5iv-site.0.2.2.css">
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">General-Purpose Computing 
<br class="ltx_break">on a 
<br class="ltx_break">Semantic Network Substrate<span id="footnote1" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup><span class="ltx_tag ltx_tag_note">1</span>Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010.</span></span></span>
</h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Marko A. Rodriguez
<br class="ltx_break">Digital Library Research and Prototyping Team 
<br class="ltx_break">Los Alamos National Laboratory 
<br class="ltx_break">Los Alamos, New Mexico 87545
<br class="ltx_break">
</span></span>
</div>
<div class="ltx_dates">(original: April 16, 2007 revision: October 7, 2007)</div>

<div class="ltx_abstract">
<h6 class="ltx_title ltx_title_abstract">Abstract</h6>
<p id="id1.id1" class="ltx_p">This article presents a model of general-purpose computing on a semantic network substrate. The concepts presented are applicable to any semantic network representation. However, due to the standards and technological infrastructure devoted to the Semantic Web effort, this article is presented from this point of view. In the proposed model of computing, the application programming interface, the run-time program, and the state of the computing virtual machine are all represented in the Resource Description Framework (RDF). The implementation of the concepts presented provides a practical computing paradigm that leverages the highly-distributed and standardized representational-layer of the Semantic Web.

<br class="ltx_break">
<br class="ltx_break"><span id="id1.id1.1" class="ltx_text ltx_font_bold">keywords:</span> Resource Description Framework, Web Ontology Language, Virtual Machines, Object-Oriented Programming, Semantic Web Computing</p>
</div>
<section id="S1" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">1 </span>Introduction</h2>

<div id="S1.p1" class="ltx_para">
<p id="S1.p1.1" class="ltx_p">This article discusses computing in semantic networks. A semantic network is a directed labeled graph ( ?). The thesis of this article is that the state of a computing machine, its low-level instructions, and the executing program can be represented as a semantic network. The computational model that is presented can be instantiated using any semantic network representation. However, given the existence of the Resource Description Framework (RDF) ( ?) and the popular Web Ontology Language (OWL) ( ?), this article presents the theory and the application in terms of these constructs.</p>
</div>
<div id="S1.p2" class="ltx_para">
<p id="S1.p2.1" class="ltx_p">The computing model that is proposed is perhaps simple in theory, but in application, requires a relatively strong background in the computer sciences. This article discusses a wide breadth of concepts including those from computer architecture, the Semantic Web, and object-oriented programming. In order to accommodate all interested readers, each discipline’s concepts will be introduced at a tutorial level in this introduction. The remainder of the article presents a more in-depth practical application of the proposed model. The practical application includes a specification for an RDF virtual machine architecture (RVM) called Fhat (pronounced făt, like “fat”) and an RDF programming language designed specifically for that architecture called Neno (pronounced nēnō, like “knee-know”).</p>
</div>
<div id="S1.p3" class="ltx_para">
<p id="S1.p3.1" class="ltx_p">The introduction to this article is split into three subsections. §<a href="#S1.SS1" title="1.1 General-Purpose Computing and the Virtual Machine ‣ 1 Introduction ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">1.1</span></a> provides a brief introduction to the field of computer architecture in order to elucidate those concepts which will be of primary interest later in the article.
§<a href="#S1.SS2" title="1.2 The Semantic Web and RDF ‣ 1 Introduction ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">1.2</span></a> discusses the Semantic Web and the RDF semantic network data model. Finally, §<a href="#S1.SS3" title="1.3 Object-Oriented Programming and OWL ‣ 1 Introduction ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">1.3</span></a> provides an overview of object-oriented programming and its relation to OWL.</p>
</div>
<section id="S1.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">1.1 </span>General-Purpose Computing and the Virtual Machine</h3>

<div id="S1.SS1.p1" class="ltx_para">
<p id="S1.SS1.p1.1" class="ltx_p">A general-purpose computer is one that can support any known computation. The meaning of computability and what is required to compute was first developed by Alan Turning in the late 1930s ( ?). Since then, and with the large leaps in the engineering of computing machines, most computers of today are general-purpose computing machines. The two primary components of a computing machine are the central processing unit (CPU) and the main memory (RAM).</p>
</div>
<div id="S1.SS1.p2" class="ltx_para">
<p id="S1.SS1.p2.1" class="ltx_p">The purpose of the CPU is to perform calculations (i.e. execute algorithms on data). Generally, the CPU reads instructions and data from RAM, performs a calculation, and re-inserts its results back into RAM. Most CPUs maintain a relatively small set of instructions that they can execute ( ?). Example instructions include <span id="S1.SS1.p2.1.1" class="ltx_text ltx_font_typewriter">add</span>, <span id="S1.SS1.p2.1.2" class="ltx_text ltx_font_typewriter">sub</span>, <span id="S1.SS1.p2.1.3" class="ltx_text ltx_font_typewriter">load</span>, <span id="S1.SS1.p2.1.4" class="ltx_text ltx_font_typewriter">store</span>, <span id="S1.SS1.p2.1.5" class="ltx_text ltx_font_typewriter">branch</span>, <span id="S1.SS1.p2.1.6" class="ltx_text ltx_font_typewriter">goto</span>, etc. However, these primitive instructions can be composed to perform any computing task desired by the programmer.</p>
</div>
<div id="S1.SS1.p3" class="ltx_para">
<p id="S1.SS1.p3.3" class="ltx_p">Currently, the smallest unit of information in a digital computer is the bit. A bit can either be a <math id="S1.SS1.p3.1.m1.1" class="ltx_Math" alttext="0" display="inline"><semantics id="S1.SS1.p3.1.m1.1a"><mn id="S1.SS1.p3.1.m1.1.1" xref="S1.SS1.p3.1.m1.1.1.cmml">0</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.1.m1.1b"><cn type="integer" id="S1.SS1.p3.1.m1.1.1.cmml" xref="S1.SS1.p3.1.m1.1.1">0</cn></annotation-xml></semantics></math> or a <math id="S1.SS1.p3.2.m2.1" class="ltx_Math" alttext="1" display="inline"><semantics id="S1.SS1.p3.2.m2.1a"><mn id="S1.SS1.p3.2.m2.1.1" xref="S1.SS1.p3.2.m2.1.1.cmml">1</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.2.m2.1b"><cn type="integer" id="S1.SS1.p3.2.m2.1.1.cmml" xref="S1.SS1.p3.2.m2.1.1">1</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p3.2.m2.1c">1</annotation></semantics></math>. Bits are combined to form bytes (8-bits) and words (machine architecture dependent). Most desktop machines of everyday use have a 32-bit word and are called 32-bit machines. 32-bits can be used to represent <math id="S1.SS1.p3.3.m3.1" class="ltx_Math" alttext="2^{32}" display="inline"><semantics id="S1.SS1.p3.3.m3.1a"><msup id="S1.SS1.p3.3.m3.1.1" xref="S1.SS1.p3.3.m3.1.1.cmml"><mn id="S1.SS1.p3.3.m3.1.1.2" xref="S1.SS1.p3.3.m3.1.1.2.cmml">2</mn><mn id="S1.SS1.p3.3.m3.1.1.3" xref="S1.SS1.p3.3.m3.1.1.3.cmml">32</mn></msup><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.3.m3.1b"><apply id="S1.SS1.p3.3.m3.1.1.cmml" xref="S1.SS1.p3.3.m3.1.1"><csymbol cd="ambiguous" id="S1.SS1.p3.3.m3.1.1.1.cmml" xref="S1.SS1.p3.3.m3.1.1">superscript</csymbol><cn type="integer" id="S1.SS1.p3.3.m3.1.1.2.cmml" xref="S1.SS1.p3.3.m3.1.1.2">2</cn><cn type="integer" id="S1.SS1.p3.3.m3.1.1.3.cmml" xref="S1.SS1.p3.3.m3.1.1.3">32</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p3.3.m3.1c">2^{32}</annotation></semantics></math> different “things”. For example, an unsigned 32-bit integer can represent the numbers 0 to 4,294,967,295. While instructions, like data, are represented as a series of 0s and 1s, it is possible to represent the instructions in a more human readable form. The abstraction above binary machine language is called assembly language ( ?). For example, the following three assembly instructions</p>
<pre id="S1.SS1.p3.13" class="ltx_verbatim ltx_font_typewriter">

load 2, 3
load 1, 2
add 1, 2, 3
store 3, 2

</pre>
<p id="S1.SS1.p3.12" class="ltx_p">instruct the CPU to 1) read the word in the memory cell at memory address <math id="S1.SS1.p3.4.m1.1" class="ltx_Math" alttext="2" display="inline"><semantics id="S1.SS1.p3.4.m1.1a"><mn id="S1.SS1.p3.4.m1.1.1" xref="S1.SS1.p3.4.m1.1.1.cmml">2</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.4.m1.1b"><cn type="integer" id="S1.SS1.p3.4.m1.1.1.cmml" xref="S1.SS1.p3.4.m1.1.1">2</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p3.4.m1.1c">2</annotation></semantics></math> in RAM and store it in CPU register <math id="S1.SS1.p3.5.m2.1" class="ltx_Math" alttext="3" display="inline"><semantics id="S1.SS1.p3.5.m2.1a"><mn id="S1.SS1.p3.5.m2.1.1" xref="S1.SS1.p3.5.m2.1.1.cmml">3</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.5.m2.1b"><cn type="integer" id="S1.SS1.p3.5.m2.1.1.cmml" xref="S1.SS1.p3.5.m2.1.1">3</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p3.5.m2.1c">3</annotation></semantics></math>, 2) read the word at memory address <math id="S1.SS1.p3.6.m3.1" class="ltx_Math" alttext="1" display="inline"><semantics id="S1.SS1.p3.6.m3.1a"><mn id="S1.SS1.p3.6.m3.1.1" xref="S1.SS1.p3.6.m3.1.1.cmml">1</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.6.m3.1b"><cn type="integer" id="S1.SS1.p3.6.m3.1.1.cmml" xref="S1.SS1.p3.6.m3.1.1">1</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p3.6.m3.1c">1</annotation></semantics></math> and store it in register <math id="S1.SS1.p3.7.m4.1" class="ltx_Math" alttext="2" display="inline"><semantics id="S1.SS1.p3.7.m4.1a"><mn id="S1.SS1.p3.7.m4.1.1" xref="S1.SS1.p3.7.m4.1.1.cmml">2</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.7.m4.1b"><cn type="integer" id="S1.SS1.p3.7.m4.1.1.cmml" xref="S1.SS1.p3.7.m4.1.1">2</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p3.7.m4.1c">2</annotation></semantics></math>, 3) add the contents of register <math id="S1.SS1.p3.8.m5.1" class="ltx_Math" alttext="1" display="inline"><semantics id="S1.SS1.p3.8.m5.1a"><mn id="S1.SS1.p3.8.m5.1.1" xref="S1.SS1.p3.8.m5.1.1.cmml">1</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.8.m5.1b"><cn type="integer" id="S1.SS1.p3.8.m5.1.1.cmml" xref="S1.SS1.p3.8.m5.1.1">1</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p3.8.m5.1c">1</annotation></semantics></math> and <math id="S1.SS1.p3.9.m6.1" class="ltx_Math" alttext="2" display="inline"><semantics id="S1.SS1.p3.9.m6.1a"><mn id="S1.SS1.p3.9.m6.1.1" xref="S1.SS1.p3.9.m6.1.1.cmml">2</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.9.m6.1b"><cn type="integer" id="S1.SS1.p3.9.m6.1.1.cmml" xref="S1.SS1.p3.9.m6.1.1">2</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p3.9.m6.1c">2</annotation></semantics></math> and store the result in register <math id="S1.SS1.p3.10.m7.1" class="ltx_Math" alttext="3" display="inline"><semantics id="S1.SS1.p3.10.m7.1a"><mn id="S1.SS1.p3.10.m7.1.1" xref="S1.SS1.p3.10.m7.1.1.cmml">3</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.10.m7.1b"><cn type="integer" id="S1.SS1.p3.10.m7.1.1.cmml" xref="S1.SS1.p3.10.m7.1.1">3</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p3.10.m7.1c">3</annotation></semantics></math>, and finally 4) store the word in register <math id="S1.SS1.p3.11.m8.1" class="ltx_Math" alttext="3" display="inline"><semantics id="S1.SS1.p3.11.m8.1a"><mn id="S1.SS1.p3.11.m8.1.1" xref="S1.SS1.p3.11.m8.1.1.cmml">3</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.11.m8.1b"><cn type="integer" id="S1.SS1.p3.11.m8.1.1.cmml" xref="S1.SS1.p3.11.m8.1.1">3</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p3.11.m8.1c">3</annotation></semantics></math> into memory address <math id="S1.SS1.p3.12.m9.1" class="ltx_Math" alttext="2" display="inline"><semantics id="S1.SS1.p3.12.m9.1a"><mn id="S1.SS1.p3.12.m9.1.1" xref="S1.SS1.p3.12.m9.1.1.cmml">2</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p3.12.m9.1b"><cn type="integer" id="S1.SS1.p3.12.m9.1.1.cmml" xref="S1.SS1.p3.12.m9.1.1">2</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p3.12.m9.1c">2</annotation></semantics></math> of RAM.</p>
</div>
<div id="S1.SS1.p4" class="ltx_para">
<p id="S1.SS1.p4.4" class="ltx_p">Modern day computer languages are written at a much higher level of abstraction than both machine and assembly language. For instance, the previous instructions could be represented by a single statement as</p>
<pre id="S1.SS1.p4.5" class="ltx_verbatim ltx_font_typewriter">

z = y + x

</pre>
<p id="S1.SS1.p4.3" class="ltx_p">where register <math id="S1.SS1.p4.1.m1.1" class="ltx_Math" alttext="1" display="inline"><semantics id="S1.SS1.p4.1.m1.1a"><mn id="S1.SS1.p4.1.m1.1.1" xref="S1.SS1.p4.1.m1.1.1.cmml">1</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p4.1.m1.1b"><cn type="integer" id="S1.SS1.p4.1.m1.1.1.cmml" xref="S1.SS1.p4.1.m1.1.1">1</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p4.1.m1.1c">1</annotation></semantics></math> holds the value of variable <span id="S1.SS1.p4.3.1" class="ltx_text ltx_font_typewriter">y</span>, register <math id="S1.SS1.p4.2.m2.1" class="ltx_Math" alttext="2" display="inline"><semantics id="S1.SS1.p4.2.m2.1a"><mn id="S1.SS1.p4.2.m2.1.1" xref="S1.SS1.p4.2.m2.1.1.cmml">2</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p4.2.m2.1b"><cn type="integer" id="S1.SS1.p4.2.m2.1.1.cmml" xref="S1.SS1.p4.2.m2.1.1">2</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p4.2.m2.1c">2</annotation></semantics></math> holds the value of variable <span id="S1.SS1.p4.3.2" class="ltx_text ltx_font_typewriter">x</span> and memory address <math id="S1.SS1.p4.3.m3.1" class="ltx_Math" alttext="3" display="inline"><semantics id="S1.SS1.p4.3.m3.1a"><mn id="S1.SS1.p4.3.m3.1.1" xref="S1.SS1.p4.3.m3.1.1.cmml">3</mn><annotation-xml encoding="MathML-Content" id="S1.SS1.p4.3.m3.1b"><cn type="integer" id="S1.SS1.p4.3.m3.1.1.cmml" xref="S1.SS1.p4.3.m3.1.1">3</cn></annotation-xml><annotation encoding="application/x-tex" id="S1.SS1.p4.3.m3.1c">3</annotation></semantics></math> holds the value of variable <span id="S1.SS1.p4.3.3" class="ltx_text ltx_font_typewriter">z</span>.</p>
</div>
<div id="S1.SS1.p5" class="ltx_para">
<p id="S1.SS1.p5.1" class="ltx_p">To the modern-day programmer, the low-level CPU instructions are hidden. It is the role of the language compiler to translate the human readable/writeable source code into the machine code of the CPU. Simply stated, a compiler is a computer program that translates information written in one language to another language ( ?). In practice, the compiler translates the human code to a list of CPU instructions that are stored in RAM and executed by the CPU in sequential order as pointed to by the CPU’s program counter (PC). In some instances, the compiler will translate the human code to the native language of the CPU (the instruction set of the CPU). In other cases, the compiler will translate the human code to another language for a virtual machine to compute ( ?). Virtual machine language is called byte-code. A virtual machine is, for all practical purposes, a CPU represented in software, not hardware. However, depending on the complexity of the implementation, a virtual machine can either do a hard implementation (where an exact software replica of hardware is instantiated) or a soft implementation (where more of the hardware components are black-boxed in software). The virtual machine computes its byte-code instructions by using the underlying hardware CPU’s instruction set. Finally, to complete the computation stack, the CPU relies on the underlying physical laws of nature to compute its instructions. The laws of physics drive the CPU from state to state. The evolution of states and its effects on the world is computing.</p>
</div>
<div id="S1.SS1.p6" class="ltx_para">
<p id="S1.SS1.p6.1" class="ltx_p">Perhaps the most popular virtual machine is the Java virtual machine (JVM) ( ?) of the Java programming language ( ?). The JVM is a piece of software that runs on a physical machine. The JVM has its own instruction set much like a hardware CPU has its own instruction set. The JVM resides in RAM and requires the physical CPU to compute its evolution. Thus, the JVM translates its instructions to the instruction set of the native CPU. The benefit of this model is that irrespective of the underlying hardware CPU, a JVM designed for that CPU architecture can read and process any Java software (i.e. any Java byte-code). The drawback, is that the computation is slower than when instructions are represented as instructions for the native CPU.</p>
</div>
</section>
<section id="S1.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">1.2 </span>The Semantic Web and RDF</h3>

<div id="S1.SS2.p1" class="ltx_para">
<p id="S1.SS2.p1.1" class="ltx_p">The previous section described the most fundamental aspects of computing. This section presents one of the most abstract levels of computing: the Semantic Web. The primary goal of the Semantic Web effort is to provide a standardized framework for describing resources (both physical and conceptual) and their relationships to one another ( ?). This framework is called the Resource Description Framework (RDF) ( ?).<span id="footnote2" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">2</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">2</sup><span class="ltx_tag ltx_tag_note">2</span>Note that RDF is a data model, not a syntax. RDF has many different syntaxes like RDF/XML ( ?), Notation 3 (N3) ( ?), the N-TRIPLE format ( ?), and TRiX ( ?).</span></span></span></p>
</div>
<div id="S1.SS2.p2" class="ltx_para">
<p id="S1.SS2.p2.1" class="ltx_p">RDF maintains two central tenets. The first states that the lowest unit of representation is the Universal Resource Identifier (URI) ( ?) and the literal (i.e. strings, integers, floating point numbers, etc.).<span id="footnote3" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">3</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">3</sup><span class="ltx_tag ltx_tag_note">3</span>There also exist blank or anonymous nodes. There will be no discussion of blank nodes in this article.</span></span></span> A URI unambiguously identifies a resource. When two resources share the same URI, they are the same resource. However, note that when two resources do not share the same URI, this does not necessarily mean that they are not the same resource. In practice, URIs are namespaced to ensure that name conflicts do not occur across different organizations ( ?). For example, the URI <span id="S1.SS2.p2.1.1" class="ltx_text ltx_font_typewriter">http://www.newspaper.org/Article</span> can have a different meaning, or connotation, than <span id="S1.SS2.p2.1.2" class="ltx_text ltx_font_typewriter">http://www.science.net/Article</span> because they are from different namespaces.<span id="footnote4" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">4</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">4</sup><span class="ltx_tag ltx_tag_note">4</span>For the sake of brevity, prefixes are usually used instead of the full namespace. For instance, <span id="footnote4.1" class="ltx_text ltx_font_typewriter">http://www.w3.org/1999/02/22-rdf-syntax-ns#</span> is prefixed as <span id="footnote4.2" class="ltx_text ltx_font_typewriter">rdf:</span>.</span></span></span></p>
</div>
<div id="S1.SS2.p3" class="ltx_para">
<p id="S1.SS2.p3.4" class="ltx_p">The second tenet of RDF states that URIs and literal values are connected to one another in sets of triples, denoting
edges of a directed labeled graph. A triple is the smallest relational fact that can be asserted about the world ( ?). For instance, the statement “I am”, can be denoted <math id="S1.SS2.p3.1.m1.3" class="ltx_Math" alttext="(\texttt{I},\texttt{am},\texttt{I})" display="inline"><semantics id="S1.SS2.p3.1.m1.3a"><mrow id="S1.SS2.p3.1.m1.3.4.2" xref="S1.SS2.p3.1.m1.3.4.1.cmml"><mo stretchy="false" id="S1.SS2.p3.1.m1.3.4.2.1" xref="S1.SS2.p3.1.m1.3.4.1.cmml">(</mo><mtext class="ltx_mathvariant_monospace" id="S1.SS2.p3.1.m1.1.1" xref="S1.SS2.p3.1.m1.1.1a.cmml">I</mtext><mo id="S1.SS2.p3.1.m1.3.4.2.2" xref="S1.SS2.p3.1.m1.3.4.1.cmml">,</mo><mtext class="ltx_mathvariant_monospace" id="S1.SS2.p3.1.m1.2.2" xref="S1.SS2.p3.1.m1.2.2a.cmml">am</mtext><mo id="S1.SS2.p3.1.m1.3.4.2.3" xref="S1.SS2.p3.1.m1.3.4.1.cmml">,</mo><mtext class="ltx_mathvariant_monospace" id="S1.SS2.p3.1.m1.3.3" xref="S1.SS2.p3.1.m1.3.3a.cmml">I</mtext><mo stretchy="false" id="S1.SS2.p3.1.m1.3.4.2.4" xref="S1.SS2.p3.1.m1.3.4.1.cmml">)</mo></mrow><annotation-xml encoding="MathML-Content" id="S1.SS2.p3.1.m1.3b"><vector id="S1.SS2.p3.1.m1.3.4.1.cmml" xref="S1.SS2.p3.1.m1.3.4.2"><ci id="S1.SS2.p3.1.m1.1.1a.cmml" xref="S1.SS2.p3.1.m1.1.1"><mtext class="ltx_mathvariant_monospace" id="S1.SS2.p3.1.m1.1.1.cmml" xref="S1.SS2.p3.1.m1.1.1">I</mtext></ci><ci id="S1.SS2.p3.1.m1.2.2a.cmml" xref="S1.SS2.p3.1.m1.2.2"><mtext class="ltx_mathvariant_monospace" id="S1.SS2.p3.1.m1.2.2.cmml" xref="S1.SS2.p3.1.m1.2.2">am</mtext></ci><ci id="S1.SS2.p3.1.m1.3.3a.cmml" xref="S1.SS2.p3.1.m1.3.3"><mtext class="ltx_mathvariant_monospace" id="S1.SS2.p3.1.m1.3.3.cmml" xref="S1.SS2.p3.1.m1.3.3">I</mtext></ci></vector></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p3.1.m1.3c">(\texttt{I},\texttt{am},\texttt{I})</annotation></semantics></math> in triple form. The first element of the triple is called the subject and can be any URI. The second element is called the predicate, and it can also be any URI. Finally, the third element is called the object, and it can be any URI or literal. If <math id="S1.SS2.p3.2.m2.1" class="ltx_Math" alttext="U" display="inline"><semantics id="S1.SS2.p3.2.m2.1a"><mi id="S1.SS2.p3.2.m2.1.1" xref="S1.SS2.p3.2.m2.1.1.cmml">U</mi><annotation-xml encoding="MathML-Content" id="S1.SS2.p3.2.m2.1b"><ci id="S1.SS2.p3.2.m2.1.1.cmml" xref="S1.SS2.p3.2.m2.1.1">𝑈</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p3.2.m2.1c">U</annotation></semantics></math> denotes the set of all URIs and <math id="S1.SS2.p3.3.m3.1" class="ltx_Math" alttext="L" display="inline"><semantics id="S1.SS2.p3.3.m3.1a"><mi id="S1.SS2.p3.3.m3.1.1" xref="S1.SS2.p3.3.m3.1.1.cmml">L</mi><annotation-xml encoding="MathML-Content" id="S1.SS2.p3.3.m3.1b"><ci id="S1.SS2.p3.3.m3.1.1.cmml" xref="S1.SS2.p3.3.m3.1.1">𝐿</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p3.3.m3.1c">L</annotation></semantics></math> denotes the set of all literals, then an RDF network denoted <math id="S1.SS2.p3.4.m4.1" class="ltx_Math" alttext="G" display="inline"><semantics id="S1.SS2.p3.4.m4.1a"><mi id="S1.SS2.p3.4.m4.1.1" xref="S1.SS2.p3.4.m4.1.1.cmml">G</mi><annotation-xml encoding="MathML-Content" id="S1.SS2.p3.4.m4.1b"><ci id="S1.SS2.p3.4.m4.1.1.cmml" xref="S1.SS2.p3.4.m4.1.1">𝐺</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p3.4.m4.1c">G</annotation></semantics></math> can be defined as</p>
<table id="S1.Ex1" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex1.m1.1" class="ltx_Math" alttext="G\subseteq(U\times U\times(U\cup L))." display="block"><semantics id="S1.Ex1.m1.1a"><mrow id="S1.Ex1.m1.1.1.1" xref="S1.Ex1.m1.1.1.1.1.cmml"><mrow id="S1.Ex1.m1.1.1.1.1" xref="S1.Ex1.m1.1.1.1.1.cmml"><mi id="S1.Ex1.m1.1.1.1.1.3" xref="S1.Ex1.m1.1.1.1.1.3.cmml">G</mi><mo id="S1.Ex1.m1.1.1.1.1.2" xref="S1.Ex1.m1.1.1.1.1.2.cmml">⊆</mo><mrow id="S1.Ex1.m1.1.1.1.1.1.1" xref="S1.Ex1.m1.1.1.1.1.1.1.1.cmml"><mo stretchy="false" id="S1.Ex1.m1.1.1.1.1.1.1.2" xref="S1.Ex1.m1.1.1.1.1.1.1.1.cmml">(</mo><mrow id="S1.Ex1.m1.1.1.1.1.1.1.1" xref="S1.Ex1.m1.1.1.1.1.1.1.1.cmml"><mi id="S1.Ex1.m1.1.1.1.1.1.1.1.3" xref="S1.Ex1.m1.1.1.1.1.1.1.1.3.cmml">U</mi><mo lspace="0.222em" rspace="0.222em" id="S1.Ex1.m1.1.1.1.1.1.1.1.2" xref="S1.Ex1.m1.1.1.1.1.1.1.1.2.cmml">×</mo><mi id="S1.Ex1.m1.1.1.1.1.1.1.1.4" xref="S1.Ex1.m1.1.1.1.1.1.1.1.4.cmml">U</mi><mo lspace="0.222em" rspace="0.222em" id="S1.Ex1.m1.1.1.1.1.1.1.1.2a" xref="S1.Ex1.m1.1.1.1.1.1.1.1.2.cmml">×</mo><mrow id="S1.Ex1.m1.1.1.1.1.1.1.1.1.1" xref="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.cmml"><mo stretchy="false" id="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.2" xref="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.cmml">(</mo><mrow id="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1" xref="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.cmml"><mi id="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.2" xref="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.2.cmml">U</mi><mo id="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.1" xref="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.1.cmml">∪</mo><mi id="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.3" xref="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.3.cmml">L</mi></mrow><mo stretchy="false" id="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.3" xref="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.cmml">)</mo></mrow></mrow><mo stretchy="false" id="S1.Ex1.m1.1.1.1.1.1.1.3" xref="S1.Ex1.m1.1.1.1.1.1.1.1.cmml">)</mo></mrow></mrow><mo lspace="0em" id="S1.Ex1.m1.1.1.1.2" xref="S1.Ex1.m1.1.1.1.1.cmml">.</mo></mrow><annotation-xml encoding="MathML-Content" id="S1.Ex1.m1.1b"><apply id="S1.Ex1.m1.1.1.1.1.cmml" xref="S1.Ex1.m1.1.1.1"><subset id="S1.Ex1.m1.1.1.1.1.2.cmml" xref="S1.Ex1.m1.1.1.1.1.2"></subset><ci id="S1.Ex1.m1.1.1.1.1.3.cmml" xref="S1.Ex1.m1.1.1.1.1.3">𝐺</ci><apply id="S1.Ex1.m1.1.1.1.1.1.1.1.cmml" xref="S1.Ex1.m1.1.1.1.1.1.1"><times id="S1.Ex1.m1.1.1.1.1.1.1.1.2.cmml" xref="S1.Ex1.m1.1.1.1.1.1.1.1.2"></times><ci id="S1.Ex1.m1.1.1.1.1.1.1.1.3.cmml" xref="S1.Ex1.m1.1.1.1.1.1.1.1.3">𝑈</ci><ci id="S1.Ex1.m1.1.1.1.1.1.1.1.4.cmml" xref="S1.Ex1.m1.1.1.1.1.1.1.1.4">𝑈</ci><apply id="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.cmml" xref="S1.Ex1.m1.1.1.1.1.1.1.1.1.1"><union id="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.1.cmml" xref="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.1"></union><ci id="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.2.cmml" xref="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.2">𝑈</ci><ci id="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.3.cmml" xref="S1.Ex1.m1.1.1.1.1.1.1.1.1.1.1.3">𝐿</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.Ex1.m1.1c">G\subseteq(U\times U\times(U\cup L)).</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="S1.SS2.p3.5" class="ltx_p">RDF has attracted commercial and scholarly interest, not only because of the Semantic Web vision, but because RDF provides a unique way of modeling data. This enthusiasm has sparked the development and distribution of various triple-store applications dedicated to the storage and manipulation of RDF networks ( ?). Some triple-stores can support computations on RDF networks that are on the order of <math id="S1.SS2.p3.5.m1.1" class="ltx_Math" alttext="10^{10}" display="inline"><semantics id="S1.SS2.p3.5.m1.1a"><msup id="S1.SS2.p3.5.m1.1.1" xref="S1.SS2.p3.5.m1.1.1.cmml"><mn id="S1.SS2.p3.5.m1.1.1.2" xref="S1.SS2.p3.5.m1.1.1.2.cmml">10</mn><mn id="S1.SS2.p3.5.m1.1.1.3" xref="S1.SS2.p3.5.m1.1.1.3.cmml">10</mn></msup><annotation-xml encoding="MathML-Content" id="S1.SS2.p3.5.m1.1b"><apply id="S1.SS2.p3.5.m1.1.1.cmml" xref="S1.SS2.p3.5.m1.1.1"><csymbol cd="ambiguous" id="S1.SS2.p3.5.m1.1.1.1.cmml" xref="S1.SS2.p3.5.m1.1.1">superscript</csymbol><cn type="integer" id="S1.SS2.p3.5.m1.1.1.2.cmml" xref="S1.SS2.p3.5.m1.1.1.2">10</cn><cn type="integer" id="S1.SS2.p3.5.m1.1.1.3.cmml" xref="S1.SS2.p3.5.m1.1.1.3">10</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p3.5.m1.1c">10^{10}</annotation></semantics></math> triples ( ?). A triple-store is analagous to a relational database. However, instead of representing data in relational tables, a triple-store represents its data as a semantic network. A triple-store provides an interface to an RDF network for the purpose of reading from and writing to the RDF network. The most implemented query language is the SPARQL Protocol and RDF Query Language (SPARQL) ( ?). SPARQL, loosely, is a hybrid of both SQL (a relational database language) and Prolog (a logic programming language) ( ?). As an example, the following SPARQL query returns all URIs that are both a type of <span id="S1.SS2.p3.5.1" class="ltx_text ltx_font_typewriter">CognitiveScientist</span> and <span id="S1.SS2.p3.5.2" class="ltx_text ltx_font_typewriter">ComputerScientist</span>.</p>
<pre id="S1.SS2.p3.6" class="ltx_verbatim ltx_font_typewriter">

 SELECT ?x
 WHERE {
   ?x &lt;rdf:type&gt; &lt;ComputerScientist&gt; .
   ?x &lt;rdf:type&gt; &lt;CognitiveScientist&gt; }
 
</pre>
<p id="S1.SS2.p3.7" class="ltx_p">The example SPARQL query will bind the variable <span id="S1.SS2.p3.7.1" class="ltx_text ltx_font_typewriter">?x</span> to all URIs that are the subject of the triples with a predicate of <span id="S1.SS2.p3.7.2" class="ltx_text ltx_font_typewriter">rdf:type</span> and objects of <span id="S1.SS2.p3.7.3" class="ltx_text ltx_font_typewriter">ComputerScientist</span> and <span id="S1.SS2.p3.7.4" class="ltx_text ltx_font_typewriter">CognitiveScientist</span>. For the example RDF network diagrammed in Figure <a href="#S1.F1" title="Figure 1 ‣ 1.2 The Semantic Web and RDF ‣ 1 Introduction ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>, <span id="S1.SS2.p3.7.5" class="ltx_text ltx_font_typewriter">?x</span> would bind to <span id="S1.SS2.p3.7.6" class="ltx_text ltx_font_typewriter">Marko</span>. Thus, the query above would return <span id="S1.SS2.p3.7.7" class="ltx_text ltx_font_typewriter">Marko</span>.<span id="footnote5" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">5</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">5</sup><span class="ltx_tag ltx_tag_note">5</span>Many triple-store applications support reasoning about resources during a query (at run-time). For example, suppose that the triple (<span id="footnote5.1" class="ltx_text ltx_font_typewriter">Marko</span>, <span id="footnote5.2" class="ltx_text ltx_font_typewriter">rdf:type</span>, <span id="footnote5.3" class="ltx_text ltx_font_typewriter">ComputerScientist</span>) does not exist in the RDF network, but instead there exist the triples (<span id="footnote5.4" class="ltx_text ltx_font_typewriter">Marko</span>, <span id="footnote5.5" class="ltx_text ltx_font_typewriter">rdf:type</span>, <span id="footnote5.6" class="ltx_text ltx_font_typewriter">ComputerEngineer</span>) and (<span id="footnote5.7" class="ltx_text ltx_font_typewriter">ComputerEngineer</span>, <span id="footnote5.8" class="ltx_text ltx_font_typewriter">owl:sameAs</span>, <span id="footnote5.9" class="ltx_text ltx_font_typewriter">ComputerScientist</span>). With OWL reasoning, <math id="footnote5.m1.1" class="ltx_Math" alttext="?x" display="inline"><semantics id="footnote5.m1.1b"><mrow id="footnote5.m1.1.1" xref="footnote5.m1.1.1.cmml"><mi mathvariant="normal" id="footnote5.m1.1.1.2" xref="footnote5.m1.1.1.2.cmml">?</mi><mo lspace="0em" rspace="0em" id="footnote5.m1.1.1.1" xref="footnote5.m1.1.1.1.cmml">​</mo><mi id="footnote5.m1.1.1.3" xref="footnote5.m1.1.1.3.cmml">x</mi></mrow><annotation-xml encoding="MathML-Content" id="footnote5.m1.1c"><apply id="footnote5.m1.1.1.cmml" xref="footnote5.m1.1.1"><times id="footnote5.m1.1.1.1.cmml" xref="footnote5.m1.1.1.1"></times><ci id="footnote5.m1.1.1.2.cmml" xref="footnote5.m1.1.1.2">?</ci><ci id="footnote5.m1.1.1.3.cmml" xref="footnote5.m1.1.1.3">𝑥</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="footnote5.m1.1d">?x</annotation></semantics></math> would still bind to <span id="footnote5.10" class="ltx_text ltx_font_typewriter">Marko</span> because <span id="footnote5.11" class="ltx_text ltx_font_typewriter">ComputerEngineer</span> and <span id="footnote5.12" class="ltx_text ltx_font_typewriter">ComputerScientist</span> are the same according to OWL semantics. The RDF computing concepts presented in this article primarily focus on triple pattern matching and thus, beyond direct URI and literal name matching, no other semantics are used.</span></span></span></p>
</div>
<figure id="S1.F1" class="ltx_figure"><img src="/html/0704.3395/assets/x1.png" id="S1.F1.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="188" height="77" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 1: </span>An example RDF network.</figcaption>
</figure>
<div id="S1.SS2.p4" class="ltx_para">
<p id="S1.SS2.p4.12" class="ltx_p">The previous query can be represented in its more set theoretic sense as</p>
<table id="Sx1.EGx1" class="ltx_equationgroup ltx_eqn_align ltx_eqn_table">

<tbody id="S1.Ex2"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><math id="S1.Ex2.m1.1" class="ltx_Math" alttext="\displaystyle X=\;" display="inline"><semantics id="S1.Ex2.m1.1a"><mrow id="S1.Ex2.m1.1.1" xref="S1.Ex2.m1.1.1.cmml"><mi id="S1.Ex2.m1.1.1.2" xref="S1.Ex2.m1.1.1.2.cmml">X</mi><mo rspace="0.558em" id="S1.Ex2.m1.1.1.1" xref="S1.Ex2.m1.1.1.1.cmml">=</mo><mi id="S1.Ex2.m1.1.1.3" xref="S1.Ex2.m1.1.1.3.cmml"></mi></mrow><annotation-xml encoding="MathML-Content" id="S1.Ex2.m1.1b"><apply id="S1.Ex2.m1.1.1.cmml" xref="S1.Ex2.m1.1.1"><eq id="S1.Ex2.m1.1.1.1.cmml" xref="S1.Ex2.m1.1.1.1"></eq><ci id="S1.Ex2.m1.1.1.2.cmml" xref="S1.Ex2.m1.1.1.2">𝑋</ci><csymbol cd="latexml" id="S1.Ex2.m1.1.1.3.cmml" xref="S1.Ex2.m1.1.1.3">absent</csymbol></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.Ex2.m1.1c">\displaystyle X=\;</annotation></semantics></math></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S1.Ex2.m2.2" class="ltx_math_unparsed" alttext="\displaystyle\{?x\;|\;(?x,\texttt{rdf:type},\texttt{ComputerScientist})\in G" display="inline"><semantics id="S1.Ex2.m2.2a"><mrow id="S1.Ex2.m2.2b"><mo stretchy="false" id="S1.Ex2.m2.2.3">{</mo><mi mathvariant="normal" id="S1.Ex2.m2.2.4">?</mi><mi id="S1.Ex2.m2.2.5">x</mi><mo fence="false" lspace="0.280em" rspace="0.447em" stretchy="false" id="S1.Ex2.m2.2.6">|</mo><mrow id="S1.Ex2.m2.2.7"><mo stretchy="false" id="S1.Ex2.m2.2.7.1">(</mo><mi mathvariant="normal" id="S1.Ex2.m2.2.7.2">?</mi><mi id="S1.Ex2.m2.2.7.3">x</mi><mo id="S1.Ex2.m2.2.7.4">,</mo><mtext class="ltx_mathvariant_monospace" id="S1.Ex2.m2.1.1">rdf:type</mtext><mo id="S1.Ex2.m2.2.7.5">,</mo><mtext class="ltx_mathvariant_monospace" id="S1.Ex2.m2.2.2">ComputerScientist</mtext><mo stretchy="false" id="S1.Ex2.m2.2.7.6">)</mo></mrow><mo id="S1.Ex2.m2.2.8">∈</mo><mi id="S1.Ex2.m2.2.9">G</mi></mrow><annotation encoding="application/x-tex" id="S1.Ex2.m2.2c">\displaystyle\{?x\;|\;(?x,\texttt{rdf:type},\texttt{ComputerScientist})\in G</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S1.Ex3"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_eqn_cell"></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><math id="S1.Ex3.m1.2" class="ltx_math_unparsed" alttext="\displaystyle\;\;\;\;\wedge\;(?x,\texttt{rdf:type},\texttt{CognitiveScientist})\in G\}," display="inline"><semantics id="S1.Ex3.m1.2a"><mrow id="S1.Ex3.m1.2b"><mo rspace="0.502em" id="S1.Ex3.m1.2.3">∧</mo><mrow id="S1.Ex3.m1.2.4"><mo stretchy="false" id="S1.Ex3.m1.2.4.1">(</mo><mi mathvariant="normal" id="S1.Ex3.m1.2.4.2">?</mi><mi id="S1.Ex3.m1.2.4.3">x</mi><mo id="S1.Ex3.m1.2.4.4">,</mo><mtext class="ltx_mathvariant_monospace" id="S1.Ex3.m1.1.1">rdf:type</mtext><mo id="S1.Ex3.m1.2.4.5">,</mo><mtext class="ltx_mathvariant_monospace" id="S1.Ex3.m1.2.2">CognitiveScientist</mtext><mo stretchy="false" id="S1.Ex3.m1.2.4.6">)</mo></mrow><mo id="S1.Ex3.m1.2.5">∈</mo><mi id="S1.Ex3.m1.2.6">G</mi><mo stretchy="false" id="S1.Ex3.m1.2.7">}</mo><mo id="S1.Ex3.m1.2.8">,</mo></mrow><annotation encoding="application/x-tex" id="S1.Ex3.m1.2c">\displaystyle\;\;\;\;\wedge\;(?x,\texttt{rdf:type},\texttt{CognitiveScientist})\in G\},</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="S1.SS2.p4.7" class="ltx_p">where <math id="S1.SS2.p4.1.m1.1" class="ltx_Math" alttext="X" display="inline"><semantics id="S1.SS2.p4.1.m1.1a"><mi id="S1.SS2.p4.1.m1.1.1" xref="S1.SS2.p4.1.m1.1.1.cmml">X</mi><annotation-xml encoding="MathML-Content" id="S1.SS2.p4.1.m1.1b"><ci id="S1.SS2.p4.1.m1.1.1.cmml" xref="S1.SS2.p4.1.m1.1.1">𝑋</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p4.1.m1.1c">X</annotation></semantics></math> is the set of URIs that bind to <math id="S1.SS2.p4.2.m2.1" class="ltx_Math" alttext="?x" display="inline"><semantics id="S1.SS2.p4.2.m2.1a"><mrow id="S1.SS2.p4.2.m2.1.1" xref="S1.SS2.p4.2.m2.1.1.cmml"><mi mathvariant="normal" id="S1.SS2.p4.2.m2.1.1.2" xref="S1.SS2.p4.2.m2.1.1.2.cmml">?</mi><mo lspace="0em" rspace="0em" id="S1.SS2.p4.2.m2.1.1.1" xref="S1.SS2.p4.2.m2.1.1.1.cmml">​</mo><mi id="S1.SS2.p4.2.m2.1.1.3" xref="S1.SS2.p4.2.m2.1.1.3.cmml">x</mi></mrow><annotation-xml encoding="MathML-Content" id="S1.SS2.p4.2.m2.1b"><apply id="S1.SS2.p4.2.m2.1.1.cmml" xref="S1.SS2.p4.2.m2.1.1"><times id="S1.SS2.p4.2.m2.1.1.1.cmml" xref="S1.SS2.p4.2.m2.1.1.1"></times><ci id="S1.SS2.p4.2.m2.1.1.2.cmml" xref="S1.SS2.p4.2.m2.1.1.2">?</ci><ci id="S1.SS2.p4.2.m2.1.1.3.cmml" xref="S1.SS2.p4.2.m2.1.1.3">𝑥</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p4.2.m2.1c">?x</annotation></semantics></math> and <math id="S1.SS2.p4.3.m3.1" class="ltx_Math" alttext="G" display="inline"><semantics id="S1.SS2.p4.3.m3.1a"><mi id="S1.SS2.p4.3.m3.1.1" xref="S1.SS2.p4.3.m3.1.1.cmml">G</mi><annotation-xml encoding="MathML-Content" id="S1.SS2.p4.3.m3.1b"><ci id="S1.SS2.p4.3.m3.1.1.cmml" xref="S1.SS2.p4.3.m3.1.1">𝐺</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p4.3.m3.1c">G</annotation></semantics></math> is the RDF network represented as an edge list. The above syntax’s semantics is “<math id="S1.SS2.p4.4.m4.1" class="ltx_Math" alttext="X" display="inline"><semantics id="S1.SS2.p4.4.m4.1a"><mi id="S1.SS2.p4.4.m4.1.1" xref="S1.SS2.p4.4.m4.1.1.cmml">X</mi><annotation-xml encoding="MathML-Content" id="S1.SS2.p4.4.m4.1b"><ci id="S1.SS2.p4.4.m4.1.1.cmml" xref="S1.SS2.p4.4.m4.1.1">𝑋</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p4.4.m4.1c">X</annotation></semantics></math> is the set of all elements <math id="S1.SS2.p4.5.m5.1" class="ltx_Math" alttext="?x" display="inline"><semantics id="S1.SS2.p4.5.m5.1a"><mrow id="S1.SS2.p4.5.m5.1.1" xref="S1.SS2.p4.5.m5.1.1.cmml"><mi mathvariant="normal" id="S1.SS2.p4.5.m5.1.1.2" xref="S1.SS2.p4.5.m5.1.1.2.cmml">?</mi><mo lspace="0em" rspace="0em" id="S1.SS2.p4.5.m5.1.1.1" xref="S1.SS2.p4.5.m5.1.1.1.cmml">​</mo><mi id="S1.SS2.p4.5.m5.1.1.3" xref="S1.SS2.p4.5.m5.1.1.3.cmml">x</mi></mrow><annotation-xml encoding="MathML-Content" id="S1.SS2.p4.5.m5.1b"><apply id="S1.SS2.p4.5.m5.1.1.cmml" xref="S1.SS2.p4.5.m5.1.1"><times id="S1.SS2.p4.5.m5.1.1.1.cmml" xref="S1.SS2.p4.5.m5.1.1.1"></times><ci id="S1.SS2.p4.5.m5.1.1.2.cmml" xref="S1.SS2.p4.5.m5.1.1.2">?</ci><ci id="S1.SS2.p4.5.m5.1.1.3.cmml" xref="S1.SS2.p4.5.m5.1.1.3">𝑥</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p4.5.m5.1c">?x</annotation></semantics></math> such that <math id="S1.SS2.p4.6.m6.1" class="ltx_Math" alttext="?x" display="inline"><semantics id="S1.SS2.p4.6.m6.1a"><mrow id="S1.SS2.p4.6.m6.1.1" xref="S1.SS2.p4.6.m6.1.1.cmml"><mi mathvariant="normal" id="S1.SS2.p4.6.m6.1.1.2" xref="S1.SS2.p4.6.m6.1.1.2.cmml">?</mi><mo lspace="0em" rspace="0em" id="S1.SS2.p4.6.m6.1.1.1" xref="S1.SS2.p4.6.m6.1.1.1.cmml">​</mo><mi id="S1.SS2.p4.6.m6.1.1.3" xref="S1.SS2.p4.6.m6.1.1.3.cmml">x</mi></mrow><annotation-xml encoding="MathML-Content" id="S1.SS2.p4.6.m6.1b"><apply id="S1.SS2.p4.6.m6.1.1.cmml" xref="S1.SS2.p4.6.m6.1.1"><times id="S1.SS2.p4.6.m6.1.1.1.cmml" xref="S1.SS2.p4.6.m6.1.1.1"></times><ci id="S1.SS2.p4.6.m6.1.1.2.cmml" xref="S1.SS2.p4.6.m6.1.1.2">?</ci><ci id="S1.SS2.p4.6.m6.1.1.3.cmml" xref="S1.SS2.p4.6.m6.1.1.3">𝑥</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p4.6.m6.1c">?x</annotation></semantics></math> is the head of the triple ending with <span id="S1.SS2.p4.7.1" class="ltx_text ltx_font_typewriter">rdf:type</span>, <span id="S1.SS2.p4.7.2" class="ltx_text ltx_font_typewriter">ComputerScientist</span> and the head of the triple ending with <span id="S1.SS2.p4.7.3" class="ltx_text ltx_font_typewriter">rdf:type</span>, <span id="S1.SS2.p4.7.4" class="ltx_text ltx_font_typewriter">CognitiveScientist</span>, where both triples are in the triple list <math id="S1.SS2.p4.7.m7.1" class="ltx_Math" alttext="G" display="inline"><semantics id="S1.SS2.p4.7.m7.1a"><mi id="S1.SS2.p4.7.m7.1.1" xref="S1.SS2.p4.7.m7.1.1.cmml">G</mi><annotation-xml encoding="MathML-Content" id="S1.SS2.p4.7.m7.1b"><ci id="S1.SS2.p4.7.m7.1.1.cmml" xref="S1.SS2.p4.7.m7.1.1">𝐺</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p4.7.m7.1c">G</annotation></semantics></math>”. Only recently has there been a proposal to extend SPARQL to support writing and deleting triples to and from an RDF network. SPARQL/Update ( ?) can be used to add the fact that <span id="S1.SS2.p4.7.5" class="ltx_text ltx_font_typewriter">Marko</span> is also an <span id="S1.SS2.p4.7.6" class="ltx_text ltx_font_typewriter">rdf:type</span> of <span id="S1.SS2.p4.7.7" class="ltx_text ltx_font_typewriter">Human</span>.</p>
<pre id="S1.SS2.p4.13" class="ltx_verbatim ltx_font_typewriter">

INSERT { &lt;Marko&gt; &lt;rdf:type&gt; &lt;Human&gt; . }
 
</pre>
<p id="S1.SS2.p4.14" class="ltx_p">In a more set theoretic notation, this statement is equivalent to</p>
<table id="S1.Ex4" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex4.m1.4" class="ltx_Math" alttext="G=G\cup(\texttt{Marko},\texttt{rdf:type},\texttt{Human})." display="block"><semantics id="S1.Ex4.m1.4a"><mrow id="S1.Ex4.m1.4.4.1" xref="S1.Ex4.m1.4.4.1.1.cmml"><mrow id="S1.Ex4.m1.4.4.1.1" xref="S1.Ex4.m1.4.4.1.1.cmml"><mi id="S1.Ex4.m1.4.4.1.1.2" xref="S1.Ex4.m1.4.4.1.1.2.cmml">G</mi><mo id="S1.Ex4.m1.4.4.1.1.1" xref="S1.Ex4.m1.4.4.1.1.1.cmml">=</mo><mrow id="S1.Ex4.m1.4.4.1.1.3" xref="S1.Ex4.m1.4.4.1.1.3.cmml"><mi id="S1.Ex4.m1.4.4.1.1.3.2" xref="S1.Ex4.m1.4.4.1.1.3.2.cmml">G</mi><mo id="S1.Ex4.m1.4.4.1.1.3.1" xref="S1.Ex4.m1.4.4.1.1.3.1.cmml">∪</mo><mrow id="S1.Ex4.m1.4.4.1.1.3.3.2" xref="S1.Ex4.m1.4.4.1.1.3.3.1.cmml"><mo stretchy="false" id="S1.Ex4.m1.4.4.1.1.3.3.2.1" xref="S1.Ex4.m1.4.4.1.1.3.3.1.cmml">(</mo><mtext class="ltx_mathvariant_monospace" id="S1.Ex4.m1.1.1" xref="S1.Ex4.m1.1.1a.cmml">Marko</mtext><mo id="S1.Ex4.m1.4.4.1.1.3.3.2.2" xref="S1.Ex4.m1.4.4.1.1.3.3.1.cmml">,</mo><mtext class="ltx_mathvariant_monospace" id="S1.Ex4.m1.2.2" xref="S1.Ex4.m1.2.2a.cmml">rdf:type</mtext><mo id="S1.Ex4.m1.4.4.1.1.3.3.2.3" xref="S1.Ex4.m1.4.4.1.1.3.3.1.cmml">,</mo><mtext class="ltx_mathvariant_monospace" id="S1.Ex4.m1.3.3" xref="S1.Ex4.m1.3.3a.cmml">Human</mtext><mo stretchy="false" id="S1.Ex4.m1.4.4.1.1.3.3.2.4" xref="S1.Ex4.m1.4.4.1.1.3.3.1.cmml">)</mo></mrow></mrow></mrow><mo lspace="0em" id="S1.Ex4.m1.4.4.1.2" xref="S1.Ex4.m1.4.4.1.1.cmml">.</mo></mrow><annotation-xml encoding="MathML-Content" id="S1.Ex4.m1.4b"><apply id="S1.Ex4.m1.4.4.1.1.cmml" xref="S1.Ex4.m1.4.4.1"><eq id="S1.Ex4.m1.4.4.1.1.1.cmml" xref="S1.Ex4.m1.4.4.1.1.1"></eq><ci id="S1.Ex4.m1.4.4.1.1.2.cmml" xref="S1.Ex4.m1.4.4.1.1.2">𝐺</ci><apply id="S1.Ex4.m1.4.4.1.1.3.cmml" xref="S1.Ex4.m1.4.4.1.1.3"><union id="S1.Ex4.m1.4.4.1.1.3.1.cmml" xref="S1.Ex4.m1.4.4.1.1.3.1"></union><ci id="S1.Ex4.m1.4.4.1.1.3.2.cmml" xref="S1.Ex4.m1.4.4.1.1.3.2">𝐺</ci><vector id="S1.Ex4.m1.4.4.1.1.3.3.1.cmml" xref="S1.Ex4.m1.4.4.1.1.3.3.2"><ci id="S1.Ex4.m1.1.1a.cmml" xref="S1.Ex4.m1.1.1"><mtext class="ltx_mathvariant_monospace" id="S1.Ex4.m1.1.1.cmml" xref="S1.Ex4.m1.1.1">Marko</mtext></ci><ci id="S1.Ex4.m1.2.2a.cmml" xref="S1.Ex4.m1.2.2"><mtext class="ltx_mathvariant_monospace" id="S1.Ex4.m1.2.2.cmml" xref="S1.Ex4.m1.2.2">rdf:type</mtext></ci><ci id="S1.Ex4.m1.3.3a.cmml" xref="S1.Ex4.m1.3.3"><mtext class="ltx_mathvariant_monospace" id="S1.Ex4.m1.3.3.cmml" xref="S1.Ex4.m1.3.3">Human</mtext></ci></vector></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.Ex4.m1.4c">G=G\cup(\texttt{Marko},\texttt{rdf:type},\texttt{Human}).</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="S1.SS2.p4.9" class="ltx_p">The semantics of the previous statement is: “Set the triple list <math id="S1.SS2.p4.8.m1.1" class="ltx_Math" alttext="G" display="inline"><semantics id="S1.SS2.p4.8.m1.1a"><mi id="S1.SS2.p4.8.m1.1.1" xref="S1.SS2.p4.8.m1.1.1.cmml">G</mi><annotation-xml encoding="MathML-Content" id="S1.SS2.p4.8.m1.1b"><ci id="S1.SS2.p4.8.m1.1.1.cmml" xref="S1.SS2.p4.8.m1.1.1">𝐺</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p4.8.m1.1c">G</annotation></semantics></math> to the current triple list <math id="S1.SS2.p4.9.m2.1" class="ltx_Math" alttext="G" display="inline"><semantics id="S1.SS2.p4.9.m2.1a"><mi id="S1.SS2.p4.9.m2.1.1" xref="S1.SS2.p4.9.m2.1.1.cmml">G</mi><annotation-xml encoding="MathML-Content" id="S1.SS2.p4.9.m2.1b"><ci id="S1.SS2.p4.9.m2.1.1.cmml" xref="S1.SS2.p4.9.m2.1.1">𝐺</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p4.9.m2.1c">G</annotation></semantics></math> unioned with the triple (<span id="S1.SS2.p4.9.1" class="ltx_text ltx_font_typewriter">Marko</span>, <span id="S1.SS2.p4.9.2" class="ltx_text ltx_font_typewriter">rdf:type</span>, <span id="S1.SS2.p4.9.3" class="ltx_text ltx_font_typewriter">Human</span>). Finally, it is possible to remove a triple using SPARQL/Update. For instance,</p>
<pre id="S1.SS2.p4.15" class="ltx_verbatim ltx_font_typewriter">

DELETE { &lt;I&gt; &lt;am&gt; &lt;I&gt; . }
 
</pre>
<p id="S1.SS2.p4.16" class="ltx_p">In set theoretic notation, this is equivalent to</p>
<table id="S1.Ex5" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex5.m1.4" class="ltx_Math" alttext="G=G\setminus(\texttt{I},\texttt{am},\texttt{I})," display="block"><semantics id="S1.Ex5.m1.4a"><mrow id="S1.Ex5.m1.4.4.1" xref="S1.Ex5.m1.4.4.1.1.cmml"><mrow id="S1.Ex5.m1.4.4.1.1" xref="S1.Ex5.m1.4.4.1.1.cmml"><mi id="S1.Ex5.m1.4.4.1.1.2" xref="S1.Ex5.m1.4.4.1.1.2.cmml">G</mi><mo id="S1.Ex5.m1.4.4.1.1.1" xref="S1.Ex5.m1.4.4.1.1.1.cmml">=</mo><mrow id="S1.Ex5.m1.4.4.1.1.3" xref="S1.Ex5.m1.4.4.1.1.3.cmml"><mi id="S1.Ex5.m1.4.4.1.1.3.2" xref="S1.Ex5.m1.4.4.1.1.3.2.cmml">G</mi><mo id="S1.Ex5.m1.4.4.1.1.3.1" xref="S1.Ex5.m1.4.4.1.1.3.1.cmml">∖</mo><mrow id="S1.Ex5.m1.4.4.1.1.3.3.2" xref="S1.Ex5.m1.4.4.1.1.3.3.1.cmml"><mo stretchy="false" id="S1.Ex5.m1.4.4.1.1.3.3.2.1" xref="S1.Ex5.m1.4.4.1.1.3.3.1.cmml">(</mo><mtext class="ltx_mathvariant_monospace" id="S1.Ex5.m1.1.1" xref="S1.Ex5.m1.1.1a.cmml">I</mtext><mo id="S1.Ex5.m1.4.4.1.1.3.3.2.2" xref="S1.Ex5.m1.4.4.1.1.3.3.1.cmml">,</mo><mtext class="ltx_mathvariant_monospace" id="S1.Ex5.m1.2.2" xref="S1.Ex5.m1.2.2a.cmml">am</mtext><mo id="S1.Ex5.m1.4.4.1.1.3.3.2.3" xref="S1.Ex5.m1.4.4.1.1.3.3.1.cmml">,</mo><mtext class="ltx_mathvariant_monospace" id="S1.Ex5.m1.3.3" xref="S1.Ex5.m1.3.3a.cmml">I</mtext><mo stretchy="false" id="S1.Ex5.m1.4.4.1.1.3.3.2.4" xref="S1.Ex5.m1.4.4.1.1.3.3.1.cmml">)</mo></mrow></mrow></mrow><mo id="S1.Ex5.m1.4.4.1.2" xref="S1.Ex5.m1.4.4.1.1.cmml">,</mo></mrow><annotation-xml encoding="MathML-Content" id="S1.Ex5.m1.4b"><apply id="S1.Ex5.m1.4.4.1.1.cmml" xref="S1.Ex5.m1.4.4.1"><eq id="S1.Ex5.m1.4.4.1.1.1.cmml" xref="S1.Ex5.m1.4.4.1.1.1"></eq><ci id="S1.Ex5.m1.4.4.1.1.2.cmml" xref="S1.Ex5.m1.4.4.1.1.2">𝐺</ci><apply id="S1.Ex5.m1.4.4.1.1.3.cmml" xref="S1.Ex5.m1.4.4.1.1.3"><setdiff id="S1.Ex5.m1.4.4.1.1.3.1.cmml" xref="S1.Ex5.m1.4.4.1.1.3.1"></setdiff><ci id="S1.Ex5.m1.4.4.1.1.3.2.cmml" xref="S1.Ex5.m1.4.4.1.1.3.2">𝐺</ci><vector id="S1.Ex5.m1.4.4.1.1.3.3.1.cmml" xref="S1.Ex5.m1.4.4.1.1.3.3.2"><ci id="S1.Ex5.m1.1.1a.cmml" xref="S1.Ex5.m1.1.1"><mtext class="ltx_mathvariant_monospace" id="S1.Ex5.m1.1.1.cmml" xref="S1.Ex5.m1.1.1">I</mtext></ci><ci id="S1.Ex5.m1.2.2a.cmml" xref="S1.Ex5.m1.2.2"><mtext class="ltx_mathvariant_monospace" id="S1.Ex5.m1.2.2.cmml" xref="S1.Ex5.m1.2.2">am</mtext></ci><ci id="S1.Ex5.m1.3.3a.cmml" xref="S1.Ex5.m1.3.3"><mtext class="ltx_mathvariant_monospace" id="S1.Ex5.m1.3.3.cmml" xref="S1.Ex5.m1.3.3">I</mtext></ci></vector></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.Ex5.m1.4c">G=G\setminus(\texttt{I},\texttt{am},\texttt{I}),</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="S1.SS2.p4.11" class="ltx_p">where the semantics are“set the triple list <math id="S1.SS2.p4.10.m1.1" class="ltx_Math" alttext="G" display="inline"><semantics id="S1.SS2.p4.10.m1.1a"><mi id="S1.SS2.p4.10.m1.1.1" xref="S1.SS2.p4.10.m1.1.1.cmml">G</mi><annotation-xml encoding="MathML-Content" id="S1.SS2.p4.10.m1.1b"><ci id="S1.SS2.p4.10.m1.1.1.cmml" xref="S1.SS2.p4.10.m1.1.1">𝐺</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p4.10.m1.1c">G</annotation></semantics></math> to the current triple list <math id="S1.SS2.p4.11.m2.1" class="ltx_Math" alttext="G" display="inline"><semantics id="S1.SS2.p4.11.m2.1a"><mi id="S1.SS2.p4.11.m2.1.1" xref="S1.SS2.p4.11.m2.1.1.cmml">G</mi><annotation-xml encoding="MathML-Content" id="S1.SS2.p4.11.m2.1b"><ci id="S1.SS2.p4.11.m2.1.1.cmml" xref="S1.SS2.p4.11.m2.1.1">𝐺</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.SS2.p4.11.m2.1c">G</annotation></semantics></math> minus the triple (<span id="S1.SS2.p4.11.1" class="ltx_text ltx_font_typewriter">I</span>, <span id="S1.SS2.p4.11.2" class="ltx_text ltx_font_typewriter">am</span>, <span id="S1.SS2.p4.11.3" class="ltx_text ltx_font_typewriter">I</span>)”.</p>
</div>
</section>
<section id="S1.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">1.3 </span>Object-Oriented Programming and OWL</h3>

<div id="S1.SS3.p1" class="ltx_para">
<p id="S1.SS3.p1.1" class="ltx_p">OWL is an ontology modeling language represented completely in RDF. In OWL, it is possible to model abstract classes and their relationships to one another as well as to use these models and the semantics of OWL to reason about unspecified relationships. In OWL semantics, if <span id="S1.SS3.p1.1.1" class="ltx_text ltx_font_typewriter">Human</span> is a class and there exists the triple <span id="S1.SS3.p1.1.2" class="ltx_text ltx_font_typewriter">(Marko, rdf:type, Human</span>), then <span id="S1.SS3.p1.1.3" class="ltx_text ltx_font_typewriter">Marko</span> is considered an instance of <span id="S1.SS3.p1.1.4" class="ltx_text ltx_font_typewriter">Human</span>. The URI <span id="S1.SS3.p1.1.5" class="ltx_text ltx_font_typewriter">Human</span> is part of the ontology-level of the RDF network and the URI <span id="S1.SS3.p1.1.6" class="ltx_text ltx_font_typewriter">Marko</span> is part of the instance-level (also called the individual-level) of the RDF network. In OWL, it is possible to state that all <span id="S1.SS3.p1.1.7" class="ltx_text ltx_font_typewriter">Human</span>s can have another <span id="S1.SS3.p1.1.8" class="ltx_text ltx_font_typewriter">Human</span> as a friend. This is possible by declaring an <span id="S1.SS3.p1.1.9" class="ltx_text ltx_font_typewriter">owl:ObjectProperty</span> named <span id="S1.SS3.p1.1.10" class="ltx_text ltx_font_typewriter">hasFriend</span> that has an <span id="S1.SS3.p1.1.11" class="ltx_text ltx_font_typewriter">rdfs:domain</span> of <span id="S1.SS3.p1.1.12" class="ltx_text ltx_font_typewriter">Human</span> and an <span id="S1.SS3.p1.1.13" class="ltx_text ltx_font_typewriter">rdfs:range</span> of <span id="S1.SS3.p1.1.14" class="ltx_text ltx_font_typewriter">Human</span>. Furthermore, it is possible to restrict the cardinality of the <span id="S1.SS3.p1.1.15" class="ltx_text ltx_font_typewriter">hasFriend</span> property and thus, state that a <span id="S1.SS3.p1.1.16" class="ltx_text ltx_font_typewriter">Human</span> can have no more than one friend. This is diagrammed in Figure <a href="#S1.F2" title="Figure 2 ‣ 1.3 Object-Oriented Programming and OWL ‣ 1 Introduction ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>.<span id="footnote6" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">6</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">6</sup><span class="ltx_tag ltx_tag_note">6</span>In this article, ontology diagrams will not explicitly represent the constructs <span id="footnote6.1" class="ltx_text ltx_font_typewriter">rdfs:domain</span>, <span id="footnote6.2" class="ltx_text ltx_font_typewriter">rdfs:range</span>, nor the <span id="footnote6.3" class="ltx_text ltx_font_typewriter">owl:Restriction</span> anonymous URIs. These URIs are assumed to be apparent from the diagram. For example, the restriction shown as <span id="footnote6.4" class="ltx_text ltx_font_typewriter">[0..1]</span> in Figure <a href="#S1.F2" title="Figure 2 ‣ 1.3 Object-Oriented Programming and OWL ‣ 1 Introduction ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> is represented by an <span id="footnote6.5" class="ltx_text ltx_font_typewriter">owl:Restriction</span> for the <span id="footnote6.6" class="ltx_text ltx_font_typewriter">hasFriend</span> property where the <span id="footnote6.7" class="ltx_text ltx_font_typewriter">maxCardinality</span> is <math id="footnote6.m1.1" class="ltx_Math" alttext="1" display="inline"><semantics id="footnote6.m1.1b"><mn id="footnote6.m1.1.1" xref="footnote6.m1.1.1.cmml">1</mn><annotation-xml encoding="MathML-Content" id="footnote6.m1.1c"><cn type="integer" id="footnote6.m1.1.1.cmml" xref="footnote6.m1.1.1">1</cn></annotation-xml><annotation encoding="application/x-tex" id="footnote6.m1.1d">1</annotation></semantics></math> and <span id="footnote6.8" class="ltx_text ltx_font_typewriter">Human</span> is an <span id="footnote6.9" class="ltx_text ltx_font_typewriter">rdfs:subClassOf</span> of this <span id="footnote6.10" class="ltx_text ltx_font_typewriter">owl:Restriction</span>.</span></span></span></p>
</div>
<figure id="S1.F2" class="ltx_figure"><img src="/html/0704.3395/assets/x2.png" id="S1.F2.g1" class="ltx_graphics ltx_centering ltx_img_square" width="134" height="160" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 2: </span>An ontology and an instance is represented in an RDF network.</figcaption>
</figure>
<div id="S1.SS3.p2" class="ltx_para">
<p id="S1.SS3.p2.1" class="ltx_p">A class specification in object-oriented programming is called an application programming interface (API) ( ?). OWL ontologies share some similarities to the object-oriented API. However, OWL ontologies also differ in many respects. OWL is a description logic language that is primarily focused on a means by which to reason on RDF data. An object-oriented API is primarily focused on concretely defining classes and their explicit relationships to one another and is thus, more in line with the frames modeling paradigm. Furthermore, OWL ontologies can contain instances (i.e. individuals), allow for multiple inheritance, do not support the unique name assumption, nor the closed world assumption ( ?, ?).</p>
</div>
<div id="S1.SS3.p3" class="ltx_para">
<p id="S1.SS3.p3.1" class="ltx_p">Another aspect of OWL that differs from object-oriented APIs is that object-oriented APIs include the concept of a method. The method is an algorithmic “behavior” that forms the foundation of the evolutionary processes that drive the instances of these classes from state to state. One of the primary purposes of this article is to introduce an OWL ontology for modeling methods and their low-level machine instructions. While process information can be represented in Frame Logic (i.e. F-Logic) ( ?), this article is primarily interested in modeling methods in much the same way that they are represented in modern day object-oriented languages such as Java and C++ and in terms of their syntax, semantics, and low-level representation.</p>
</div>
<div id="S1.SS3.p4" class="ltx_para">
<p id="S1.SS3.p4.1" class="ltx_p">In Java and C++, a method is defined for a class and is used to manipulate the properties (called fields) of an instance of that class. For example,</p>
<pre id="S1.SS3.p4.2" class="ltx_verbatim ltx_font_typewriter">

class Human {
  Human hasFriend;
  void makeFriend(Human h) {
    this.hasFriend = h;
  }
}
</pre>
<p id="S1.SS3.p4.3" class="ltx_p">declares that there exists an abstract class called <span id="S1.SS3.p4.3.1" class="ltx_text ltx_font_typewriter">Human</span>. A <span id="S1.SS3.p4.3.2" class="ltx_text ltx_font_typewriter">Human</span> has one field called <span id="S1.SS3.p4.3.3" class="ltx_text ltx_font_typewriter">hasFriend</span>. The <span id="S1.SS3.p4.3.4" class="ltx_text ltx_font_typewriter">hasFriend</span> field refers to an object of type <span id="S1.SS3.p4.3.5" class="ltx_text ltx_font_typewriter">Human</span>. Furthermore, according to the class declaration, a <span id="S1.SS3.p4.3.6" class="ltx_text ltx_font_typewriter">Human</span> has a method called <span id="S1.SS3.p4.3.7" class="ltx_text ltx_font_typewriter">makeFriend</span>. The <span id="S1.SS3.p4.3.8" class="ltx_text ltx_font_typewriter">makeFriend</span> method takes a single argument that is of type <span id="S1.SS3.p4.3.9" class="ltx_text ltx_font_typewriter">Human</span> and sets its <span id="S1.SS3.p4.3.10" class="ltx_text ltx_font_typewriter">hasFriend</span> field to the <span id="S1.SS3.p4.3.11" class="ltx_text ltx_font_typewriter">Human</span> provided in the argument. The <span id="S1.SS3.p4.3.12" class="ltx_text ltx_font_typewriter">this</span> keyword makes explicit that the <span id="S1.SS3.p4.3.13" class="ltx_text ltx_font_typewriter">hasFriend</span> field is the field of the object for which the <span id="S1.SS3.p4.3.14" class="ltx_text ltx_font_typewriter">makeFriend</span> method was invoked.</p>
</div>
<div id="S1.SS3.p5" class="ltx_para">
<p id="S1.SS3.p5.1" class="ltx_p">In many object-oriented languages, an instance of <span id="S1.SS3.p5.1.1" class="ltx_text ltx_font_typewriter">Human</span> is created with the <span id="S1.SS3.p5.1.2" class="ltx_text ltx_font_typewriter">new</span> operator. For instance,</p>
<pre id="S1.SS3.p5.2" class="ltx_verbatim ltx_font_typewriter">

Human Marko = new Human();

</pre>
<p id="S1.SS3.p5.3" class="ltx_p">creates a <span id="S1.SS3.p5.3.1" class="ltx_text ltx_font_typewriter">Human</span> named (referenced as) <span id="S1.SS3.p5.3.2" class="ltx_text ltx_font_typewriter">Marko</span>. The <span id="S1.SS3.p5.3.3" class="ltx_text ltx_font_typewriter">new</span> operator is analogous to the <span id="S1.SS3.p5.3.4" class="ltx_text ltx_font_typewriter">rdf:type</span> property. Thus, after this code is executed, a similar situation exists as that which is represented in Figure <a href="#S1.F2" title="Figure 2 ‣ 1.3 Object-Oriented Programming and OWL ‣ 1 Introduction ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>. However, the ontological model diagrammed in the top half of Figure <a href="#S1.F2" title="Figure 2 ‣ 1.3 Object-Oriented Programming and OWL ‣ 1 Introduction ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> does not have the <span id="S1.SS3.p5.3.5" class="ltx_text ltx_font_typewriter">makeFriend</span> method URI. The relationship between object-oriented programming and OWL is presented in Table <a href="#S1.T1" title="Table 1 ‣ 1.3 Object-Oriented Programming and OWL ‣ 1 Introduction ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>.</p>
</div>
<figure id="S1.T1" class="ltx_table">
<table id="S1.T1.1" class="ltx_tabular ltx_centering ltx_align_middle">
<tbody class="ltx_tbody">
<tr id="S1.T1.1.1.1" class="ltx_tr">
<td id="S1.T1.1.1.1.1" class="ltx_td ltx_border_l ltx_border_r ltx_border_t"></td>
<td id="S1.T1.1.1.1.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T1.1.1.1.2.1" class="ltx_text" style="font-size:80%;">object-oriented</span></td>
<td id="S1.T1.1.1.1.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T1.1.1.1.3.1" class="ltx_text" style="font-size:80%;">OWL</span></td>
<td id="S1.T1.1.1.1.4" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T1.1.1.1.4.1" class="ltx_text" style="font-size:80%;">example</span></td>
</tr>
<tr id="S1.T1.1.2.2" class="ltx_tr">
<td id="S1.T1.1.2.2.1" class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_tt"><span id="S1.T1.1.2.2.1.1" class="ltx_text" style="font-size:80%;">class specification</span></td>
<td id="S1.T1.1.2.2.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_tt"><span id="S1.T1.1.2.2.2.1" class="ltx_text" style="font-size:80%;">API</span></td>
<td id="S1.T1.1.2.2.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_tt"><span id="S1.T1.1.2.2.3.1" class="ltx_text" style="font-size:80%;">ontology</span></td>
<td id="S1.T1.1.2.2.4" class="ltx_td ltx_align_center ltx_border_r ltx_border_tt"><span id="S1.T1.1.2.2.4.1" class="ltx_text" style="font-size:80%;">Human</span></td>
</tr>
<tr id="S1.T1.1.3.3" class="ltx_tr">
<td id="S1.T1.1.3.3.1" class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t"><span id="S1.T1.1.3.3.1.1" class="ltx_text" style="font-size:80%;">object property</span></td>
<td id="S1.T1.1.3.3.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T1.1.3.3.2.1" class="ltx_text" style="font-size:80%;">field</span></td>
<td id="S1.T1.1.3.3.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T1.1.3.3.3.1" class="ltx_text ltx_font_typewriter" style="font-size:80%;">rdf:Property</span></td>
<td id="S1.T1.1.3.3.4" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T1.1.3.3.4.1" class="ltx_text" style="font-size:80%;">hasFriend</span></td>
</tr>
<tr id="S1.T1.1.4.4" class="ltx_tr">
<td id="S1.T1.1.4.4.1" class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t"><span id="S1.T1.1.4.4.1.1" class="ltx_text" style="font-size:80%;">object method</span></td>
<td id="S1.T1.1.4.4.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T1.1.4.4.2.1" class="ltx_text" style="font-size:80%;">method</span></td>
<td id="S1.T1.1.4.4.3" class="ltx_td ltx_border_r ltx_border_t"></td>
<td id="S1.T1.1.4.4.4" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T1.1.4.4.4.1" class="ltx_text" style="font-size:80%;">makeFriend</span></td>
</tr>
<tr id="S1.T1.1.5.5" class="ltx_tr">
<td id="S1.T1.1.5.5.1" class="ltx_td ltx_align_center ltx_border_b ltx_border_l ltx_border_r ltx_border_t"><span id="S1.T1.1.5.5.1.1" class="ltx_text" style="font-size:80%;">instantiate</span></td>
<td id="S1.T1.1.5.5.2" class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t">
<span id="S1.T1.1.5.5.2.1" class="ltx_text ltx_font_typewriter" style="font-size:80%;">new</span><span id="S1.T1.1.5.5.2.2" class="ltx_text" style="font-size:80%;"> operator</span>
</td>
<td id="S1.T1.1.5.5.3" class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t">
<span id="S1.T1.1.5.5.3.1" class="ltx_text ltx_font_typewriter" style="font-size:80%;">rdf:type</span><span id="S1.T1.1.5.5.3.2" class="ltx_text" style="font-size:80%;"> property</span>
</td>
<td id="S1.T1.1.5.5.4" class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t">
<span id="S1.T1.1.5.5.4.1" class="ltx_text ltx_font_typewriter" style="font-size:80%;">new</span><span id="S1.T1.1.5.5.4.2" class="ltx_text" style="font-size:80%;">/</span><span id="S1.T1.1.5.5.4.3" class="ltx_text ltx_font_typewriter" style="font-size:80%;">rdf:type</span>
</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption ltx_centering" style="font-size:80%;"><span class="ltx_tag ltx_tag_table">Table 1: </span> The relationship between object-oriented programming, OWL, and the section example.</figcaption>
</figure>
<div id="S1.SS3.p6" class="ltx_para">
<p id="S1.SS3.p6.1" class="ltx_p">It is no large conceptual leap to attach a method URI to a class. Currently, there is no strong incentive to provide a framework for representing methods in OWL. RDF was originally developed as a data modeling framework, not a programming environment <span id="S1.SS3.p6.1.1" class="ltx_text ltx_font_italic">per se</span>. However, in a similar vein, the Web Ontology Language for Services (OWL-S) has been proposed as a web services model to support the discovery, execution, and tracking of the execution of Semantic Web services ( ?, ?). An OWL-S service exposes a service profile that describes what the service does, a service grounding that describes how to invoke the service, and a service model that describes how the service works. While OWL-S does provide the notion of object-oriented method invocation on the Semantic Web, OWL-S is more at the agent-oriented level and its intended use is for more “client/server” type problems. Another interesting and related idea is to use RDF as a medium for communication between various computing devices and thus, utilize the Semantic Web as an infrastructure for distributed computing ( ?).
Other object-oriented notions have been proposed within the context of RDF. For instance, SWCLOS ( ?) and ActiveRDF ( ?) utilize RDF as a medium for ensuring the long-term persistence of an object. Both frameworks allow their respective languages (CLOS and Ruby) to populate the fields of their objects for use in their language environments. Once their fields have been populated, the object’s methods can be invoked in their respective programming environments.</p>
</div>
</section>
<section id="S1.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">1.4 </span>The Contributions of this Article</h3>

<div id="S1.SS4.p1" class="ltx_para">
<p id="S1.SS4.p1.1" class="ltx_p">This article unifies all of the concepts presented hitherto into a framework for computing on RDF networks. In this framework, the state of a computing virtual machine, the API, and the low-level instructions are all represented in RDF. Furthermore, unlike the current programming paradigm, there is no stack of representation. The lowest level of computing and the highest level of computing are represented in the same substrate: URIs, literals, and triples.</p>
</div>
<div id="S1.SS4.p2" class="ltx_para">
<p id="S1.SS4.p2.1" class="ltx_p">This article proposes the concept of OWL APIs, RDF triple-code, and RDF virtual machines (RVM). Human readable/writeable source code is compiled to create an OWL ontology that abstractly represents how instructions should be united to form instruction sequences.<span id="footnote7" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">7</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">7</sup><span class="ltx_tag ltx_tag_note">7</span>While OWL has many features that are useful for reasoning about RDF data, the primary purpose of OWL with respect to the concepts presented in this article is to utilize OWL for its ability to create highly restricted data models. These restricted models form the APIs and ensure that instance RDF triple-code can be unambiguously generated by an RVM.</span></span></span> When objects and their methods are instantiated from an OWL API, RDF triple-code is created. RDF triple-code is analogous to virtual machine byte-code, but instead of being represented as bits, bytes, and words, it is represented as URIs and triples. In other words, a piece of executable software is represented as a traversable RDF network. The RVM is a virtual machine whose state is represented in RDF. The RVM’s stacks, program counter, frames, etc. are modeled as an RDF network. It is the role of the RVM to “walk” the traversable RDF triple-code and compute.</p>
</div>
<div id="S1.SS4.p3" class="ltx_para">
<p id="S1.SS4.p3.1" class="ltx_p">In summary, software is written in human readable/writeable source code, compiled to an OWL API, instantiated to RDF triple-code, and processed by a computing machine whose state is represented in RDF. However, there is always a homunculus. There is always some external process that drives the evolution of the representational substrate. For the JVM, that homunculus is the hardware CPU. For the hardware CPU, the homunculus is the physical laws of nature. For the RVM, the homunculus is some host CPU whether that host CPU is another virtual machine like the JVM or a hardware CPU. Table <a href="#S1.T2" title="Table 2 ‣ 1.4 The Contributions of this Article ‣ 1 Introduction ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> presents the different levels of abstraction in computing and how they are represented by the physical machine, virtual machine, and proposed RDF computing paradigms.</p>
</div>
<figure id="S1.T2" class="ltx_table">
<table id="S1.T2.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="S1.T2.1.1.1" class="ltx_tr">
<th id="S1.T2.1.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_th_row ltx_border_l ltx_border_rr ltx_border_t"><span id="S1.T2.1.1.1.1.1" class="ltx_text" style="font-size:80%;">level</span></th>
<th id="S1.T2.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S1.T2.1.1.1.2.1" class="ltx_text" style="font-size:80%;">machine paradigm</span></th>
<th id="S1.T2.1.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S1.T2.1.1.1.3.1" class="ltx_text" style="font-size:80%;">virtual machine paradigm</span></th>
<th id="S1.T2.1.1.1.4" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S1.T2.1.1.1.4.1" class="ltx_text" style="font-size:80%;">RDF paradigm</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="S1.T2.1.2.1" class="ltx_tr">
<th id="S1.T2.1.2.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_rr ltx_border_tt"><span id="S1.T2.1.2.1.1.1" class="ltx_text" style="font-size:80%;">high-level code</span></th>
<td id="S1.T2.1.2.1.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_tt"><span id="S1.T2.1.2.1.2.1" class="ltx_text" style="font-size:80%;">source code</span></td>
<td id="S1.T2.1.2.1.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_tt"><span id="S1.T2.1.2.1.3.1" class="ltx_text" style="font-size:80%;">source code</span></td>
<td id="S1.T2.1.2.1.4" class="ltx_td ltx_align_center ltx_border_r ltx_border_tt"><span id="S1.T2.1.2.1.4.1" class="ltx_text" style="font-size:80%;">source code</span></td>
</tr>
<tr id="S1.T2.1.3.2" class="ltx_tr">
<th id="S1.T2.1.3.2.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_rr ltx_border_t"><span id="S1.T2.1.3.2.1.1" class="ltx_text" style="font-size:80%;">machine code</span></th>
<td id="S1.T2.1.3.2.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T2.1.3.2.2.1" class="ltx_text" style="font-size:80%;">native instructions</span></td>
<td id="S1.T2.1.3.2.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T2.1.3.2.3.1" class="ltx_text" style="font-size:80%;">byte-code</span></td>
<td id="S1.T2.1.3.2.4" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T2.1.3.2.4.1" class="ltx_text" style="font-size:80%;">triple-code</span></td>
</tr>
<tr id="S1.T2.1.4.3" class="ltx_tr">
<th id="S1.T2.1.4.3.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_rr ltx_border_t"><span id="S1.T2.1.4.3.1.1" class="ltx_text" style="font-size:80%;">instruction units</span></th>
<td id="S1.T2.1.4.3.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T2.1.4.3.2.1" class="ltx_text" style="font-size:80%;">bits</span></td>
<td id="S1.T2.1.4.3.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T2.1.4.3.3.1" class="ltx_text" style="font-size:80%;">bits</span></td>
<td id="S1.T2.1.4.3.4" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T2.1.4.3.4.1" class="ltx_text" style="font-size:80%;">URIs and literals</span></td>
</tr>
<tr id="S1.T2.1.5.4" class="ltx_tr">
<th id="S1.T2.1.5.4.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_rr ltx_border_t"><span id="S1.T2.1.5.4.1.1" class="ltx_text" style="font-size:80%;">machine state</span></th>
<td id="S1.T2.1.5.4.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T2.1.5.4.2.1" class="ltx_text" style="font-size:80%;">hardware</span></td>
<td id="S1.T2.1.5.4.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T2.1.5.4.3.1" class="ltx_text" style="font-size:80%;">software</span></td>
<td id="S1.T2.1.5.4.4" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S1.T2.1.5.4.4.1" class="ltx_text" style="font-size:80%;">RDF</span></td>
</tr>
<tr id="S1.T2.1.6.5" class="ltx_tr">
<th id="S1.T2.1.6.5.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_b ltx_border_l ltx_border_rr ltx_border_t"><span id="S1.T2.1.6.5.1.1" class="ltx_text" style="font-size:80%;">machine execution</span></th>
<td id="S1.T2.1.6.5.2" class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t"><span id="S1.T2.1.6.5.2.1" class="ltx_text" style="font-size:80%;">physics</span></td>
<td id="S1.T2.1.6.5.3" class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t"><span id="S1.T2.1.6.5.3.1" class="ltx_text" style="font-size:80%;">hardware</span></td>
<td id="S1.T2.1.6.5.4" class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t"><span id="S1.T2.1.6.5.4.1" class="ltx_text" style="font-size:80%;">software</span></td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption ltx_centering" style="font-size:80%;"><span class="ltx_tag ltx_tag_table">Table 2: </span> The various levels of abstraction in current and proposed computing paradigms.</figcaption>
</figure>
</section>
</section>
<section id="S2" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">2 </span>A High-Level Perspective</h2>

<div id="S2.p1" class="ltx_para">
<p id="S2.p1.1" class="ltx_p">Assume there exists an RDF triple-store. Internal to that triple-store is an RDF network. That RDF network is composed of triples. A triple is a set of three URIs and/or literals. Those URIs can be used as a pointer to anything. This article presents a model of computation that is represented by URIs and literals and their interrelation to one another (triples). Thus, computation is represented as an RDF network. Figure <a href="#S2.F3" title="Figure 3 ‣ 2 A High-Level Perspective ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> presents a high-level perspective on what will be discussed throughout the remainder of this article. What is diagrammed in Figure <a href="#S2.F3" title="Figure 3 ‣ 2 A High-Level Perspective ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> is a very compartmentalized model of the components of computing. This model is in line with the common paradigm of computer science and engineering. However, less traditional realizations of this paradigm can remove the discrete levels of representation to support multi-level interactions between the various computing components since all the components are represented in the same RDF substrate: as URIs, literals, and triples.</p>
</div>
<figure id="S2.F3" class="ltx_figure"><img src="/html/0704.3395/assets/x3.png" id="S2.F3.g1" class="ltx_graphics ltx_centering ltx_img_square" width="269" height="324" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 3: </span>A high-level perspective of the Semantic Web computing environment.</figcaption>
</figure>
<div id="S2.p2" class="ltx_para">
<p id="S2.p2.1" class="ltx_p">Figure <a href="#S2.F3" title="Figure 3 ‣ 2 A High-Level Perspective ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> shows 6 primary components. Two of these components are at the ontological level of the RDF network, two are at the instance level of the RDF network, and two are at the machine level external to the RDF network. While there are many benefits that emerge from this computing model that are currently seen and as of yet unseen, established interesting aspects are enumerated below.</p>
</div>
<div id="S2.p3" class="ltx_para">
<ol id="S2.I1" class="ltx_enumerate">
<li id="S2.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">1.</span> 
<div id="S2.I1.i1.p1" class="ltx_para">
<p id="S2.I1.i1.p1.1" class="ltx_p">The total address space of the RVM is the space of all URIs and literals. In the RVM model of computing, the RVM state has no concept of the underlying hardware CPU’s address space because instructions and data are represented in RDF. This idea is discussed in §<a href="#S3.SS1" title="3.1 The Universally Unique Identifier Address Space ‣ 3 The Neno Language ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.1</span></a>.</p>
</div>
</li>
<li id="S2.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">2.</span> 
<div id="S2.I1.i2.p1" class="ltx_para">
<p id="S2.I1.i2.p1.1" class="ltx_p">The Semantic Web is no longer an information gathering infrastructure, but a distributed information processing infrastructure (the process can move to the data, the data doesn’t have to move to the process). An RVM can be “GETed” from a web-server as an RDF/XML document or “SELECTed” from an RDF triple-store. RDF programs and RVM states are “first-class” web-entities. The ramifications of this is that an RVM can move between triple-store environments and can compute on local data sets without requiring moving the data to the processor. This idea is discussed in §<a href="#S4.SS1" title="4.1 Migrating Fhat Across Different Host CPUs ‣ 4 The Fhat Virtual Machine Architecture ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">4.1</span></a>.</p>
</div>
</li>
<li id="S2.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">3.</span> 
<div id="S2.I1.i3.p1" class="ltx_para">
<p id="S2.I1.i3.p1.1" class="ltx_p">This model maintains the “write once, run anywhere” paradigm of the JVM. The RVM model ensures that human readable/writeable source code is compiled down to an intermediate language that is independent of the underlying hardware CPU executing the RVM process.</p>
</div>
</li>
<li id="S2.I1.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">4.</span> 
<div id="S2.I1.i4.p1" class="ltx_para">
<p id="S2.I1.i4.p1.1" class="ltx_p">Languages built on a semantic network substrate can have unique constructs not found in other languages (e.g. inverse field referencing, multi-instance fields, field querying, etc.). While it is theoretically possible to add these constructs to other languages, they are not provided in the core of the languages as these languages do not have an underlying semantic network data model. These novel language constructs are discussed in §<a href="#S3.SS2" title="3.2 Class Declarations in Neno Source Code ‣ 3 The Neno Language ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.2</span></a>.</p>
</div>
</li>
<li id="S2.I1.i5" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">5.</span> 
<div id="S2.I1.i5.p1" class="ltx_para">
<p id="S2.I1.i5.p1.1" class="ltx_p">Currently, there already exists an infrastructure to support the paradigm (triple-stores, ontology modeling languages, query languages, etc.) and thus, requires very little investment by the community. The primary investment is the development of source-to-OWL API compilers, RVMs, and the standardization of RDF triple-code and RVM distribution/security protocols.</p>
</div>
</li>
<li id="S2.I1.i6" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">6.</span> 
<div id="S2.I1.i6.p1" class="ltx_para">
<p id="S2.I1.i6.p1.1" class="ltx_p">An RVM can be engineered at any level of complexity. It is possible to move the complexity to the software implementing the RVM process to ease machine architecture development and speed up computing time. This idea is discussed in §<a href="#S4.SS3" title="4.3 r-Fhat ‣ 4 The Fhat Virtual Machine Architecture ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">4.3</span></a>.</p>
</div>
</li>
<li id="S2.I1.i7" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">7.</span> 
<div id="S2.I1.i7.p1" class="ltx_para">
<p id="S2.I1.i7.p1.1" class="ltx_p">In this model, language reflection exists at the API, software, and RVM level (everything is represented in RDF). This idea is discussed in §<a href="#S4.SS2" title="4.2 Fhat Reflection ‣ 4 The Fhat Virtual Machine Architecture ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">4.2</span></a>.</p>
</div>
</li>
</ol>
</div>
<section id="S2.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">2.1 </span>The Ontological Level</h3>

<div id="S2.SS1.p1" class="ltx_para">
<p id="S2.SS1.p1.1" class="ltx_p">The ontological level of the RDF network diagrammed in Figure <a href="#S2.F3" title="Figure 3 ‣ 2 A High-Level Perspective ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> is represented in OWL. This subsection will discuss the two primary ontological components: the API, and the RVM architecture.</p>
</div>
<section id="S2.SS1.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">2.1.1 </span>The API</h4>

<div id="S2.SS1.SSS1.p1" class="ltx_para">
<p id="S2.SS1.SSS1.p1.1" class="ltx_p">OWL supports the specification of class interactions. However, class interactions are specified in terms of property relationships, not method invocations. OWL has no formal way of specifying class behaviors (i.e. methods). However, in OWL, it is possible to define method and instruction classes and formally specify restrictions that dictate how instructions should be interrelated within a method. The method and instruction ontology presented in this article makes RDF a programming framework and not just a data modeling framework.</p>
</div>
</section>
<section id="S2.SS1.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">2.1.2 </span>The Machine Architecture</h4>

<div id="S2.SS1.SSS2.p1" class="ltx_para">
<p id="S2.SS1.SSS2.p1.1" class="ltx_p">The RDF machine architecture is modeled in OWL. The machine architecture ontology is an abstract description of an instance of a particular RVM. Depending on the level of abstraction required, different machine architectures can be implemented at varying levels of detail.</p>
</div>
</section>
</section>
<section id="S2.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">2.2 </span>The Instance Level</h3>

<div id="S2.SS2.p1" class="ltx_para">
<p id="S2.SS2.p1.1" class="ltx_p">The instance level of an RDF network is constrained by the requirements specified in the ontological level of the RDF network. This subsection will present the two components of the instance layer of the diagram in Figure <a href="#S2.F3" title="Figure 3 ‣ 2 A High-Level Perspective ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>.</p>
</div>
<section id="S2.SS2.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">2.2.1 </span>The Program</h4>

<div id="S2.SS2.SSS1.p1" class="ltx_para">
<p id="S2.SS2.SSS1.p1.1" class="ltx_p">An API abstractly defines a software application. When an API is instantiated, instance RDF triple-code is created. Triple-code represents the instructions used by an RVM to compute.</p>
</div>
</section>
<section id="S2.SS2.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">2.2.2 </span>The Virtual Machine</h4>

<div id="S2.SS2.SSS2.p1" class="ltx_para">
<p id="S2.SS2.SSS2.p1.1" class="ltx_p">An instance of the machine architecture is an RDF virtual machine (RVM). The purpose of the RVM is to represent its state (stacks, program counter, etc.) in the same RDF network as the triple-code instructions. However, the RDF-based RVM is not a “true” computer. The RVM simply represents its state in RDF. The RVM requires a software implementation outside the triple-store to compute its instructions. This requires the machine level discussed next.</p>
</div>
</section>
</section>
<section id="S2.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">2.3 </span>The Machine Level</h3>

<div id="S2.SS3.p1" class="ltx_para">
<p id="S2.SS3.p1.1" class="ltx_p">The machine level is where the actual computation is executed. An RDF network is a data structure. RDF is not a processor in the common sense—it has no way of evolving itself. In order to process RDF data, some external process must read and write to the RDF network. The reading and writing of the RDF network evolves the RVM and the objects on which it is computing. This section discusses the machine level that is diagrammed in Figure <a href="#S2.F3" title="Figure 3 ‣ 2 A High-Level Perspective ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>.</p>
</div>
<section id="S2.SS3.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">2.3.1 </span>The Virtual Machine Process</h4>

<div id="S2.SS3.SSS1.p1" class="ltx_para">
<p id="S2.SS3.SSS1.p1.1" class="ltx_p">The virtual machine process is represented in software on a particular host machine. The RVM processor must be compatible with both the triple-store interface (e.g. SPARQL/Update) and the underlying host machine. The RVM’s host machine can be the physical machine (hardware CPU) or another virtual machine. For instance, if the RVM’s machine process is implemented in the Java language, then the machine process runs in the JVM. This is diagrammed in Figure <a href="#S2.F3" title="Figure 3 ‣ 2 A High-Level Perspective ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> by the <span id="S2.SS3.SSS1.p1.1.1" class="ltx_text ltx_font_typewriter">...</span> component in between the virtual machine process and the physical machine.</p>
</div>
</section>
<section id="S2.SS3.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">2.3.2 </span>The Physical Machine</h4>

<div id="S2.SS3.SSS2.p1" class="ltx_para">
<p id="S2.SS3.SSS2.p1.1" class="ltx_p">The physical machine is the actual hardware CPU. The RVM implementation translates the RDF triple-code to the host machine’s instruction set. For example, if the RVM process is running on the Intel Core Duo, then it is the role of the RVM process to translate the RDF triple-code to that specified by the Intel Core Duo instruction set. Thus, portability of this architectural model relies on a per host implementation of the RVM. Finally, to complete the computational stack, the laws of physics compute the hardware CPU. Much like the RDF representation of the RVM is a “snap-shot” representation of a computation, the hardware CPU is a silicon/electron “snap-shot” representation of a computation.</p>
</div>
</section>
</section>
</section>
<section id="S3" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">3 </span>The Neno Language</h2>

<div id="S3.p1" class="ltx_para">
<p id="S3.p1.1" class="ltx_p">This section presents the specification of a programming language designed to take advantage of a pure RDF computing environment. This language is called Neno. Neno is a high-level object-oriented language that is written in a grammar similar to other object-oriented languages such as Java and C++. However, Neno provides some functionality that is not possible with other languages (i.e. not explicit in the constructs of other object-oriented languages). This functionality is not due to the sophistication of the Neno language, but instead, is due to the fact that it is written for an RDF substrate and thus, can take advantage of the flexibility of RDF and its read/write interfaces. For this reason, Neno is in a class of languages that is coined semantic network programming languages. The Ripple programming language is another such semantic network programming language ( ?). Both Neno and Ripple are Turing complete and thus, can perform any classical (non-quantum) computation.</p>
</div>
<div id="S3.p2" class="ltx_para">
<p id="S3.p2.1" class="ltx_p">Neno source code is written in human readable/writeable plain-text like the source code of many other high-level programming languages. Neno source code is compiled by a NenoFhat compiler. The NenoFhat compiler compiles Neno source code to a Fhat OWL API. The Fhat OWL API is analogous to the <span id="S3.p2.1.1" class="ltx_text ltx_font_typewriter">jar</span> file of Java. A Fhat RVM instantiates (loads) aspects of the API into the instance layer of the RDF network. This instantiated aspect of the API is executable RDF triple-code. A Fhat RVM processes the triple-code and thus, computes. The analogies between the Neno and Java components are presented in Table <a href="#S3.T3" title="Table 3 ‣ 3 The Neno Language ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>.</p>
</div>
<figure id="S3.T3" class="ltx_table">
<table id="S3.T3.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="S3.T3.1.1.1" class="ltx_tr">
<th id="S3.T3.1.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_th_row ltx_border_l ltx_border_rr ltx_border_t"><span id="S3.T3.1.1.1.1.1" class="ltx_text" style="font-size:80%;">artifact</span></th>
<th id="S3.T3.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S3.T3.1.1.1.2.1" class="ltx_text" style="font-size:80%;">Neno</span></th>
<th id="S3.T3.1.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S3.T3.1.1.1.3.1" class="ltx_text" style="font-size:80%;">Java</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="S3.T3.1.2.1" class="ltx_tr">
<th id="S3.T3.1.2.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_rr ltx_border_tt"><span id="S3.T3.1.2.1.1.1" class="ltx_text" style="font-size:80%;">source code</span></th>
<td id="S3.T3.1.2.1.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_tt"><span id="S3.T3.1.2.1.2.1" class="ltx_text" style="font-size:80%;">AClass.neno</span></td>
<td id="S3.T3.1.2.1.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_tt"><span id="S3.T3.1.2.1.3.1" class="ltx_text" style="font-size:80%;">AClass.java</span></td>
</tr>
<tr id="S3.T3.1.3.2" class="ltx_tr">
<th id="S3.T3.1.3.2.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_rr ltx_border_t"><span id="S3.T3.1.3.2.1.1" class="ltx_text" style="font-size:80%;">compiler</span></th>
<td id="S3.T3.1.3.2.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S3.T3.1.3.2.2.1" class="ltx_text" style="font-size:80%;">nenofhat</span></td>
<td id="S3.T3.1.3.2.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S3.T3.1.3.2.3.1" class="ltx_text" style="font-size:80%;">javac</span></td>
</tr>
<tr id="S3.T3.1.4.3" class="ltx_tr">
<th id="S3.T3.1.4.3.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_rr ltx_border_t"><span id="S3.T3.1.4.3.1.1" class="ltx_text" style="font-size:80%;">API</span></th>
<td id="S3.T3.1.4.3.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S3.T3.1.4.3.2.1" class="ltx_text" style="font-size:80%;">AClass.owl</span></td>
<td id="S3.T3.1.4.3.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S3.T3.1.4.3.3.1" class="ltx_text" style="font-size:80%;">AClass.class</span></td>
</tr>
<tr id="S3.T3.1.5.4" class="ltx_tr">
<th id="S3.T3.1.5.4.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_l ltx_border_rr ltx_border_t"><span id="S3.T3.1.5.4.1.1" class="ltx_text" style="font-size:80%;">virtual machine</span></th>
<td id="S3.T3.1.5.4.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S3.T3.1.5.4.2.1" class="ltx_text" style="font-size:80%;">fhat</span></td>
<td id="S3.T3.1.5.4.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S3.T3.1.5.4.3.1" class="ltx_text" style="font-size:80%;">java</span></td>
</tr>
<tr id="S3.T3.1.6.5" class="ltx_tr">
<th id="S3.T3.1.6.5.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_b ltx_border_l ltx_border_rr ltx_border_t"><span id="S3.T3.1.6.5.1.1" class="ltx_text" style="font-size:80%;">program</span></th>
<td id="S3.T3.1.6.5.2" class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t"><span id="S3.T3.1.6.5.2.1" class="ltx_text" style="font-size:80%;">RDF network</span></td>
<td id="S3.T3.1.6.5.3" class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t"><span id="S3.T3.1.6.5.3.1" class="ltx_text" style="font-size:80%;">JVM memory</span></td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption ltx_centering" style="font-size:80%;"><span class="ltx_tag ltx_tag_table">Table 3: </span> The mapping between Neno and Java components.</figcaption>
</figure>
<div id="S3.p3" class="ltx_para">
<p id="S3.p3.1" class="ltx_p">The following examples will only namespace those entities that are not within the namespace <span id="S3.p3.1.1" class="ltx_text ltx_font_typewriter">http://neno.lanl.gov</span>. Thus, the default namespace is <span id="S3.p3.1.2" class="ltx_text ltx_font_typewriter">http://neno.lanl.gov</span> (prefixed as <span id="S3.p3.1.3" class="ltx_text ltx_font_typewriter">neno</span>). The Neno programming language is engineered to be in compliance with OWL and the XML Schema Definition (XSD) namespaces. OWL provides the concept of classes, inheritance, datatype and class properties, and property restrictions. However, Neno restricts its compiled Fhat OWL APIs to single-parent classes (i.e. multiple-inheritance is not supported) and holds the closed world assumption (i.e. only properties that are stated in the ontology can be computed on in a Neno object). This is similar to what is assumed in Java. XSD provides the specification for the literal data types (e.g. string, integer, float, double, date, time, etc.). The XSD URI namespace prefix is <span id="S3.p3.1.4" class="ltx_text ltx_font_typewriter">xsd</span>.</p>
</div>
<div id="S3.p4" class="ltx_para">
<p id="S3.p4.1" class="ltx_p">The lexicon that will be used to express the following concepts is drawn from object-oriented programming, not OWL. OWL parlance will only be used when completely describing the “back-end” of a particular aspect of the language. Table <a href="#S3.T4" title="Table 4 ‣ 3 The Neno Language ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a> states the relationship between OWL terms and object-oriented programming terms.</p>
</div>
<figure id="S3.T4" class="ltx_table">
<table id="S3.T4.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="S3.T4.1.1.1" class="ltx_tr">
<th id="S3.T4.1.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_l ltx_border_r ltx_border_t"><span id="S3.T4.1.1.1.1.1" class="ltx_text" style="font-size:80%;">OWL</span></th>
<th id="S3.T4.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S3.T4.1.1.1.2.1" class="ltx_text" style="font-size:80%;">object-oriented languages</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="S3.T4.1.2.1" class="ltx_tr">
<td id="S3.T4.1.2.1.1" class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_tt"><span id="S3.T4.1.2.1.1.1" class="ltx_text ltx_font_typewriter" style="font-size:80%;">owl:Class</span></td>
<td id="S3.T4.1.2.1.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_tt"><span id="S3.T4.1.2.1.2.1" class="ltx_text" style="font-size:80%;">Class</span></td>
</tr>
<tr id="S3.T4.1.3.2" class="ltx_tr">
<td id="S3.T4.1.3.2.1" class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t"><span id="S3.T4.1.3.2.1.1" class="ltx_text ltx_font_typewriter" style="font-size:80%;">neno:Method</span></td>
<td id="S3.T4.1.3.2.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S3.T4.1.3.2.2.1" class="ltx_text" style="font-size:80%;">Method</span></td>
</tr>
<tr id="S3.T4.1.4.3" class="ltx_tr">
<td id="S3.T4.1.4.3.1" class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t"><span id="S3.T4.1.4.3.1.1" class="ltx_text ltx_font_typewriter" style="font-size:80%;">rdf:Property</span></td>
<td id="S3.T4.1.4.3.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S3.T4.1.4.3.2.1" class="ltx_text" style="font-size:80%;">Field</span></td>
</tr>
<tr id="S3.T4.1.5.4" class="ltx_tr">
<td id="S3.T4.1.5.4.1" class="ltx_td ltx_align_center ltx_border_b ltx_border_l ltx_border_r ltx_border_t">
<span id="S3.T4.1.5.4.1.1" class="ltx_text" style="font-size:80%;">subject of </span><span id="S3.T4.1.5.4.1.2" class="ltx_text ltx_font_typewriter" style="font-size:80%;">rdf:type</span>
</td>
<td id="S3.T4.1.5.4.2" class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t"><span id="S3.T4.1.5.4.2.1" class="ltx_text" style="font-size:80%;">Object</span></td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption ltx_centering" style="font-size:80%;"><span class="ltx_tag ltx_tag_table">Table 4: </span> The mapping between the terms in OWL and object-oriented programming.</figcaption>
</figure>
<section id="S3.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.1 </span>The Universally Unique Identifier Address Space</h3>

<div id="S3.SS1.p1" class="ltx_para">
<p id="S3.SS1.p1.1" class="ltx_p">Throughout the remainder of this article, Universally Unique Identifiers (UUIDs) will be continually used ( ?). The set of all UUIDs is a subset of the set of all URIs. A UUID is a 128-bit (16-byte) string that can be created in disparate environments with a near zero probability of ever being reproduced. To understand the number of UUIDs that are possible at 128-bits, it would require 1 trillion unique UUIDs to be created every nanosecond for 10 billion years to exhaust the space of all possible UUIDs.<span id="footnote8" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">8</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">8</sup><span class="ltx_tag ltx_tag_note">8</span>This fact was taken from Wikipedia at http://en.wikipedia.org/wiki/UUID.</span></span></span> A UUID can be represented as a 36 character hexadecimal string. For example, 6c3f8afe-ec3d-11db-8314-0800200c9a66, is a UUID. The hexadecimal representation will be used in all the following examples. However, for the sake of brevity, since 36 characters is too lengthy for the examples and diagrams, only the first 8 characters will be used. Thus, 6c3f8afe-ec3d-11db-8314-0800200c9a66 will be represented as 6c3f8afe. Furthermore, UUIDs, when used as URIs are namespaced as</p>
<table id="S3.Ex6" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span id="S3.Ex6.1" class="ltx_text ltx_markedasmath ltx_font_typewriter">urn:uuid:6c3f8afe-ec3d-11db-8314-0800200c9a66</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="S3.SS1.p1.2" class="ltx_p">and for diagrams and examples, is abbreviated as <span id="S3.SS1.p1.2.1" class="ltx_text ltx_font_typewriter">urn:uuid:6c3f8afe</span>.</p>
</div>
<div id="S3.SS1.p2" class="ltx_para">
<p id="S3.SS1.p2.1" class="ltx_p">When Neno source code is compiled to Fhat triple-code, a UUID is created for nearly everything; every instruction class and instruction instance is identified by a UUID. When a Fhat is instantiated, a UUID is created for all the <span id="S3.SS1.p2.1.1" class="ltx_text ltx_font_typewriter">rdfs:Resource</span>s that compose the machine (i.e. stacks, frames, etc.). In typical programming environments, the programming language and its computing machine are constrained by the size of RAM (and virtual memory with most modern day operating systems). For a 32-bit machine, the maximum size of RAM is approximately 4 gigabytes. This means that there are only <math id="S3.SS1.p2.1.m1.1" class="ltx_Math" alttext="2^{32}" display="inline"><semantics id="S3.SS1.p2.1.m1.1a"><msup id="S3.SS1.p2.1.m1.1.1" xref="S3.SS1.p2.1.m1.1.1.cmml"><mn id="S3.SS1.p2.1.m1.1.1.2" xref="S3.SS1.p2.1.m1.1.1.2.cmml">2</mn><mn id="S3.SS1.p2.1.m1.1.1.3" xref="S3.SS1.p2.1.m1.1.1.3.cmml">32</mn></msup><annotation-xml encoding="MathML-Content" id="S3.SS1.p2.1.m1.1b"><apply id="S3.SS1.p2.1.m1.1.1.cmml" xref="S3.SS1.p2.1.m1.1.1"><csymbol cd="ambiguous" id="S3.SS1.p2.1.m1.1.1.1.cmml" xref="S3.SS1.p2.1.m1.1.1">superscript</csymbol><cn type="integer" id="S3.SS1.p2.1.m1.1.1.2.cmml" xref="S3.SS1.p2.1.m1.1.1.2">2</cn><cn type="integer" id="S3.SS1.p2.1.m1.1.1.3.cmml" xref="S3.SS1.p2.1.m1.1.1.3">32</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p2.1.m1.1c">2^{32}</annotation></semantics></math> possible addresses and thus, words in RAM. However, for Neno, no such constraints exist. The space of all UUIDs is the address space of a Fhat RVM (more generally, the space of all URIs and literals is the address space). Fhat does not use RAM for storing its data and instructions, Fhat uses an RDF network. Thus, Fhat does not have any hard constraint on how much memory it “allocates” for its processing.</p>
</div>
</section>
<section id="S3.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.2 </span>Class Declarations in Neno Source Code</h3>

<div id="S3.SS2.p1" class="ltx_para">
<p id="S3.SS2.p1.1" class="ltx_p">Neno source code has a grammar that is very similar to other object-oriented languages. For instance, suppose the following simple class written in the Java programming language:
<span id="S3.SS2.p1.1.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

package gov.lanl.neno.demo;

import java.lang.*;
import java.util.*;

public class Human {
  private String hasName;
  private ArrayList&lt;Human&gt; hasFriend;

  public Human (String n) {
    this.hasName = n;
  }

  public void makeFriend(Human h) {
    if(h != this)
      this.hasFriend.add(h);
  }

  public void setName(String n) {
    this.hasName = n;
  }
}

</pre>
<p id="S3.SS2.p1.3" class="ltx_p">The <span id="S3.SS2.p1.3.1" class="ltx_text ltx_font_typewriter">Human</span> class has two fields named <span id="S3.SS2.p1.3.2" class="ltx_text ltx_font_typewriter">hasName</span> and <span id="S3.SS2.p1.3.3" class="ltx_text ltx_font_typewriter">hasFriend</span>. The field <span id="S3.SS2.p1.3.4" class="ltx_text ltx_font_typewriter">hasName</span> takes a value of <span id="S3.SS2.p1.3.5" class="ltx_text ltx_font_typewriter">String</span> (or <span id="S3.SS2.p1.3.6" class="ltx_text ltx_font_typewriter">java.lang.String</span> to be more specific) and <span id="S3.SS2.p1.3.7" class="ltx_text ltx_font_typewriter">hasFriend</span> takes a value of <span id="S3.SS2.p1.3.8" class="ltx_text ltx_font_typewriter">Human</span>. The <span id="S3.SS2.p1.3.9" class="ltx_text ltx_font_typewriter">Human</span> class has one constructor and one method. A constructor is used to create an object and is a type of method. In Java, a constructor tells the JVM to allocate memory for the object on the heap (i.e. an object “pool”) and set the object’s field values according to the statements in the body of the constructor. The constructor for <span id="S3.SS2.p1.3.10" class="ltx_text ltx_font_typewriter">Human</span> takes a <span id="S3.SS2.p1.3.11" class="ltx_text ltx_font_typewriter">String</span> called <span id="S3.SS2.p1.3.12" class="ltx_text ltx_font_typewriter">n</span> and creates a new <span id="S3.SS2.p1.3.13" class="ltx_text ltx_font_typewriter">Human</span> instance called an object. The <span id="S3.SS2.p1.3.14" class="ltx_text ltx_font_typewriter">Human</span> constructor sets that object’s <span id="S3.SS2.p1.3.15" class="ltx_text ltx_font_typewriter">hasName</span> field to <span id="S3.SS2.p1.3.16" class="ltx_text ltx_font_typewriter">n</span>. The <span id="S3.SS2.p1.3.17" class="ltx_text ltx_font_typewriter">Human</span> method is called <span id="S3.SS2.p1.3.18" class="ltx_text ltx_font_typewriter">makeFriend</span>. This method takes a <span id="S3.SS2.p1.3.19" class="ltx_text ltx_font_typewriter">Human</span> with variable name <span id="S3.SS2.p1.3.20" class="ltx_text ltx_font_typewriter">h</span> as an argument. If the object referenced by <span id="S3.SS2.p1.3.21" class="ltx_text ltx_font_typewriter">h</span> is not the <span id="S3.SS2.p1.3.22" class="ltx_text ltx_font_typewriter">Human</span> for which this method was invoked, then the object for which this method was called has <span id="S3.SS2.p1.3.23" class="ltx_text ltx_font_typewriter">h</span> added to its <span id="S3.SS2.p1.3.24" class="ltx_text ltx_font_typewriter">hasFriend</span> field. Note, that unlike the example in Figure <a href="#S1.F2" title="Figure 2 ‣ 1.3 Object-Oriented Programming and OWL ‣ 1 Introduction ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>, it is possible for a <span id="S3.SS2.p1.3.25" class="ltx_text ltx_font_typewriter">Human</span> object to have multiple friends because of the use of the <span id="S3.SS2.p1.3.26" class="ltx_text ltx_font_typewriter">ArrayList&lt;Human&gt;</span>.<span id="footnote9" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">9</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">9</sup><span class="ltx_tag ltx_tag_note">9</span>Java generics as represented by the <math id="footnote9.m1.1" class="ltx_Math" alttext="&lt;\;&gt;" display="inline"><semantics id="footnote9.m1.1b"><mrow id="footnote9.m1.1.1" xref="footnote9.m1.1.1.cmml"><mi id="footnote9.m1.1.1.2" xref="footnote9.m1.1.1.2.cmml"></mi><mo rspace="0em" id="footnote9.m1.1.1.1" xref="footnote9.m1.1.1.1.cmml">&lt;</mo><mo id="footnote9.m1.1.1.3" xref="footnote9.m1.1.1.3.cmml">&gt;</mo></mrow><annotation-xml encoding="MathML-Content" id="footnote9.m1.1c"><apply id="footnote9.m1.1.1.cmml" xref="footnote9.m1.1.1"><lt id="footnote9.m1.1.1.1.cmml" xref="footnote9.m1.1.1.1"></lt><csymbol cd="latexml" id="footnote9.m1.1.1.2.cmml" xref="footnote9.m1.1.1.2">absent</csymbol><gt id="footnote9.m1.1.1.3.cmml" xref="footnote9.m1.1.1.3"></gt></apply></annotation-xml><annotation encoding="application/x-tex" id="footnote9.m1.1d">&lt;\;&gt;</annotation></semantics></math> notation is supported by Java 1.5+.</span></span></span></p>
</div>
<div id="S3.SS2.p2" class="ltx_para">
<p id="S3.SS2.p2.1" class="ltx_p">The Neno programming language is similar to Java. The following source code demonstrates how to declare nearly the same class in Neno.<span id="footnote10" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">10</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">10</sup><span class="ltx_tag ltx_tag_note">10</span>When there are no ambiguities in naming, the class declaration can be written without prefixes.</span></span></span>
<span id="S3.SS2.p2.1.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.p2.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

prefix owl: &lt;http://www.w3.org/2002/07/owl&gt;;
prefix xsd: &lt;http://www.w3.org/2001/XMLSchema&gt;;
prefix demo: &lt;http://neno.lanl.gov/demo&gt;;

owl:Thing demo:Human {
  xsd:string hasName[1];
  demo:Human hasFriend[0..*];

  !Human(xsd:string n) {
    this.hasName = n;
  }

  makeFriend(demo:Human h) {
    if(h != this)
      this.hasFriend =+ h;
  }

  setName(xsd:string n) {
    this.hasName = n;
  }
}
</pre>
</div>
<div id="S3.SS2.p3" class="ltx_para">
<p id="S3.SS2.p3.1" class="ltx_p">While the <span id="S3.SS2.p3.1.1" class="ltx_text ltx_font_typewriter">Human</span> class declaration in Java and in Neno are nearly identical, there are a few constructs that make the two languages different. For one, instead of “importing” packages, in Neno, namespaces are declared and ontologies are imported.<span id="footnote11" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">11</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">11</sup><span class="ltx_tag ltx_tag_note">11</span>Note that languages such as Java and C++ do maintain the concept of package namespaces.</span></span></span> To ease namespace declarations, prefixes are used (e.g. <span id="S3.SS2.p3.1.2" class="ltx_text ltx_font_typewriter">owl</span>, <span id="S3.SS2.p3.1.3" class="ltx_text ltx_font_typewriter">xsd</span>, and <span id="S3.SS2.p3.1.4" class="ltx_text ltx_font_typewriter">demo</span>). All constructors are denoted by the class name prefixed by the ! symbol. Similarly, though not in the above example, all destructors are denoted by the class name prefixed by the <code id="S3.SS2.p3.1.5" class="ltx_verbatim ltx_font_typewriter">~</code> symbol. Notice that all datatype primitives (e.g. <span id="S3.SS2.p3.1.6" class="ltx_text ltx_font_typewriter">xsd:string</span>) are from the XSD namespace. The Fhat RVM is engineered specifically for these datatypes. Perhaps the most unique aspect of the Neno language is the cardinality restriction specifier in the field declaration (e.g. <span id="S3.SS2.p3.1.7" class="ltx_text ltx_font_typewriter">[0..1]</span>). Because Neno was designed for a semantic network substrate, there is nothing that prevents the same property (i.e. field) to point to multiple different URIs. In order to demand that there exist no more than one field, the <span id="S3.SS2.p3.1.8" class="ltx_text ltx_font_typewriter">[0..1]</span> notation is used. Note that <span id="S3.SS2.p3.1.9" class="ltx_text ltx_font_typewriter">demo:Human</span> is an <span id="S3.SS2.p3.1.10" class="ltx_text ltx_font_typewriter">rdfs:subClassOf</span> <span id="S3.SS2.p3.1.11" class="ltx_text ltx_font_typewriter">owl:Thing</span> as specified by the <span id="S3.SS2.p3.1.12" class="ltx_text ltx_font_typewriter">owl:Thing demo:Human</span> class description. Class inheritance is specified by the prefix to the declaration of the class name. Note that in Neno, a class can only have a single parent even though OWL supports multiple-inhertiance.<span id="footnote12" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">12</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">12</sup><span class="ltx_tag ltx_tag_note">12</span>This constraint does not apply to <span id="footnote12.1" class="ltx_text ltx_font_typewriter">owl:Restriction</span>s as Neno classes utilize <span id="footnote12.2" class="ltx_text ltx_font_typewriter">owl:Restriction</span>s to make explicit property restrictions. Thus, excluding <span id="footnote12.3" class="ltx_text ltx_font_typewriter">owl:Restriction</span> subclassing, a Neno object class can only be the subclass of a single class.</span></span></span> Furthermore, note that all class properties have a universal restriction on the class or datatype value. For example, in the above <span id="S3.SS2.p3.1.13" class="ltx_text ltx_font_typewriter">demo:Human</span> class, the <span id="S3.SS2.p3.1.14" class="ltx_text ltx_font_typewriter">hasName</span> property must have an <span id="S3.SS2.p3.1.15" class="ltx_text ltx_font_typewriter">xsd:string</span> value and all <span id="S3.SS2.p3.1.16" class="ltx_text ltx_font_typewriter">hasFriend</span> properties must have <span id="S3.SS2.p3.1.17" class="ltx_text ltx_font_typewriter">demo:Human</span> values.</p>
</div>
<div id="S3.SS2.p4" class="ltx_para">
<p id="S3.SS2.p4.1" class="ltx_p">In order to demonstrate the relationship between Neno source code and its compiled OWL API, the following simple class example is presented. The class
<span id="S3.SS2.p4.1.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.p4.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

prefix owl: &lt;http://www.w3.org/2002/07/owl&gt;;
prefix xsd: &lt;http://www.w3.org/2001/XMLSchema&gt;;
prefix demo: &lt;http://neno.lanl.gov/demo&gt;;

owl:Thing demo:Example {
  xsd:integer t[0..1];

  test(xsd:integer n) {
    for(xsd:integer i=0; i &lt; n; i++) {
      this.t = this.t + 1;
    }
  }
}

</pre>
<p id="S3.SS2.p4.3" class="ltx_p">has the following OWL RDF/XML representation:
<span id="S3.SS2.p4.3.1" class="ltx_text" style="font-size:70%;"></span></p>
<pre id="S3.SS2.p4.4" class="ltx_verbatim ltx_font_typewriter" style="font-size:70%;">
&lt;rdf:RDF
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:owl="http://www.w3.org/2002/07/owl#"&gt;
  &lt;owl:Ontology rdf:about="http://neno.lanl.gov"/&gt;
  &lt;owl:Ontology rdf:about="http://neno.lanl.gov/demo"&gt;
    &lt;owl:imports rdf:resource="http://neno.lanl.gov"/&gt;
  &lt;/owl:Ontology&gt;
  ...
  &lt;!-- A PUSHVALUE INSTRUCTION --&gt;

  &lt;owl:Class rdf:about="http://neno.lanl.gov/demo#2271ea72-877c-4090-9f89-..."&gt;
    &lt;rdfs:subClassOf rdf:resource="http://neno.lanl.gov#PushValue"/&gt;
    &lt;rdfs:subClassOf&gt;
      &lt;owl:Restriction&gt;
        &lt;owl:onProperty rdf:resource="http://neno.lanl.gov#hasValue"/&gt;
        &lt;owl:allValuesFrom&gt;
          &lt;owl:Class rdf:about="http://neno.lanl.gov/demo#9792cc3c-5600-4660-..."/&gt;
        &lt;/owl:allValuesFrom&gt;
      &lt;/owl:Restriction&gt;
    &lt;/rdfs:subClassOf&gt;
    &lt;rdfs:subClassOf&gt;
      &lt;owl:Restriction&gt;
        &lt;owl:onProperty rdf:resource="http://neno.lanl.gov#nextInst"/&gt;
        &lt;owl:allValuesFrom&gt;
          &lt;owl:Class rdf:about="http://neno.lanl.gov/demo#a80ba54c-5344-4df1-..."/&gt;
        &lt;/owl:allValuesFrom&gt;
      &lt;/owl:Restriction&gt;
    &lt;/rdfs:subClassOf&gt;
  &lt;/owl:Class&gt;

  &lt;!-- THE PUSHED VALUE --&gt;

  &lt;owl:Class rdf:about="http://neno.lanl.gov/demo#9792cc3c-5600-4660-bc1f-..."&gt;
    &lt;rdfs:subClassOf rdf:resource="http://neno.lanl.gov#LocalDirect"/&gt;
    &lt;rdfs:subClassOf&gt;
      &lt;owl:Restriction&gt;
        &lt;owl:hasValue rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"
        &gt;1&lt;/owl:hasValue&gt;
        &lt;owl:onProperty rdf:resource="http://neno.lanl.gov#hasURI"/&gt;
      &lt;/owl:Restriction&gt;
    &lt;/rdfs:subClassOf&gt;
  &lt;/owl:Class&gt;

  &lt;!-- THE NEXT INSTRUCTION AFTER THE PUSHVALUE INSTRUCTION: AN ADD INSTRUCTION --&gt;

  &lt;owl:Class rdf:about="http://neno.lanl.gov/demo#a80ba54c-5344-4df1-91a0-..."&gt;
    &lt;rdfs:subClassOf rdf:resource="http://neno.lanl.gov#Add"/&gt;
    &lt;rdfs:subClassOf&gt;
      &lt;owl:Restriction&gt;
        &lt;owl:onProperty rdf:resource="http://neno.lanl.gov#hasLeft"/&gt;
        &lt;owl:allValuesFrom rdf:resource="http://neno.lanl.gov/demo#4c715d16-b6e6-..."/&gt;
      &lt;/owl:Restriction&gt;
    &lt;/rdfs:subClassOf&gt;
    &lt;rdfs:subClassOf&gt;
      &lt;owl:Restriction&gt;
        &lt;owl:onProperty rdf:resource="http://neno.lanl.gov#hasRight"/&gt;
        &lt;owl:allValuesFrom rdf:resource="http://neno.lanl.gov/demo#fdde7f6f-b9c0-..."/&gt;
      &lt;/owl:Restriction&gt;
    &lt;/rdfs:subClassOf&gt;
    &lt;rdfs:subClassOf&gt;
      &lt;owl:Restriction&gt;
        &lt;owl:onProperty rdf:resource="http://neno.lanl.gov#nextInst"/&gt;
        &lt;owl:allValuesFrom rdf:resource="http://neno.lanl.gov/demo#e3b8a797-849b-..."/&gt;
      &lt;/owl:Restriction&gt;
    &lt;/rdfs:subClassOf&gt;
  &lt;/owl:Class&gt;
  ...
&lt;/rdf:RDF&gt;

</pre>
<p id="S3.SS2.p4.5" class="ltx_p">The most important idea to take away from the above Fhat OWL API subset is that the role of the compiler is to generate UUID-named instruction classes that are subclasses of particular Fhat instructions (e.g. <span id="S3.SS2.p4.5.1" class="ltx_text ltx_font_typewriter">PushValue</span>). These generated instruction classes have <span id="S3.SS2.p4.5.2" class="ltx_text ltx_font_typewriter">owl:Restriction</span>s on them that ensure that instances of these classes are connected to one another in an unambiguous way (e.g. <span id="S3.SS2.p4.5.3" class="ltx_text ltx_font_typewriter">owl:Restriction</span>s on their respective <span id="S3.SS2.p4.5.4" class="ltx_text ltx_font_typewriter">nextInt</span> property) and that their operand values are made explicit (e.g. <span id="S3.SS2.p4.5.5" class="ltx_text ltx_font_typewriter">owl:Restriction</span>s on their respective operand properties). This unambiguous instantiation is the RDF triple-code that is created when a Fhat RVM instantiates the API.</p>
</div>
<div id="S3.SS2.p5" class="ltx_para">
<p id="S3.SS2.p5.2" class="ltx_p">For example, in the above Fhat OWL API snippet, any <span id="S3.SS2.p5.2.3" class="ltx_text ltx_font_typewriter">demo:2271ea72</span> <span id="S3.SS2.p5.2.4" class="ltx_text ltx_font_typewriter">PushValue</span> instruction instance must have one and only one <span id="S3.SS2.p5.2.5" class="ltx_text ltx_font_typewriter">hasValue</span> property. The value of that property must be a <span id="S3.SS2.p5.2.6" class="ltx_text ltx_font_typewriter">demo:9792cc3c</span> <span id="S3.SS2.p5.2.7" class="ltx_text ltx_font_typewriter">LocalDirect</span> value with a <span id="S3.SS2.p5.2.8" class="ltx_text ltx_font_typewriter">hasURI</span> property value of <span id="S3.SS2.p5.2.2" class="ltx_text ltx_font_typewriter">"1"<sup id="S3.SS2.p5.2.2.1" class="ltx_sup"><span id="S3.SS2.p5.2.2.1.1" class="ltx_text ltx_font_serif">∧</span></sup><sup id="S3.SS2.p5.2.2.2" class="ltx_sup"><span id="S3.SS2.p5.2.2.2.1" class="ltx_text ltx_font_serif">∧</span></sup>&lt;xsd:integer&gt;</span>. The instance of <span id="S3.SS2.p5.2.9" class="ltx_text ltx_font_typewriter">demo:2271ea72</span> must also have a <span id="S3.SS2.p5.2.10" class="ltx_text ltx_font_typewriter">nextInst</span> property that is of <span id="S3.SS2.p5.2.11" class="ltx_text ltx_font_typewriter">rdf:type</span> <span id="S3.SS2.p5.2.12" class="ltx_text ltx_font_typewriter">demo:a80ba54c</span>, where <span id="S3.SS2.p5.2.13" class="ltx_text ltx_font_typewriter">demo:a80ba54c</span> is an <span id="S3.SS2.p5.2.14" class="ltx_text ltx_font_typewriter">rdfs:subClassOf</span> <span id="S3.SS2.p5.2.15" class="ltx_text ltx_font_typewriter">Add</span>. An instance of this <span id="S3.SS2.p5.2.16" class="ltx_text ltx_font_typewriter">demo:a80ba54c</span> <span id="S3.SS2.p5.2.17" class="ltx_text ltx_font_typewriter">Add</span> instruction instructs the Fhat RVM to add its <span id="S3.SS2.p5.2.18" class="ltx_text ltx_font_typewriter">hasLeft</span> operand and its <span id="S3.SS2.p5.2.19" class="ltx_text ltx_font_typewriter">hasRight</span> operands together. This <span id="S3.SS2.p5.2.20" class="ltx_text ltx_font_typewriter">demo:a80ba54c</span> <span id="S3.SS2.p5.2.21" class="ltx_text ltx_font_typewriter">Add</span> also has a <span id="S3.SS2.p5.2.22" class="ltx_text ltx_font_typewriter">nextInst</span> property value that must be an instance of <span id="S3.SS2.p5.2.23" class="ltx_text ltx_font_typewriter">demo:e3b8a797</span>. Though not shown, the <span id="S3.SS2.p5.2.24" class="ltx_text ltx_font_typewriter">demo:e3b8a797</span> is an <span id="S3.SS2.p5.2.25" class="ltx_text ltx_font_typewriter">rdfs:subClassOf</span> <span id="S3.SS2.p5.2.26" class="ltx_text ltx_font_typewriter">Set</span>. In this way, through strict <span id="S3.SS2.p5.2.27" class="ltx_text ltx_font_typewriter">owl:Restriction</span>s, the flow of triple-code can be generated in an unambiguous manner by the Fhat RVM.</p>
</div>
<div id="S3.SS2.p6" class="ltx_para">
<p id="S3.SS2.p6.1" class="ltx_p">The remainder of this section will go over the more salient aspects of the Neno programming language.</p>
</div>
<section id="S3.SS2.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.1 </span>Declaring Namespaces</h4>

<div id="S3.SS2.SSS1.p1" class="ltx_para">
<p id="S3.SS2.SSS1.p1.1" class="ltx_p">Namespaces promote the distributed nature of the Semantic Web by ensuring that there are no URI name conflicts in the ontologies and instances of different organizations ( ?). The Java language has a similar construct called packaging. The package specification in Java supports organizational namespacing. Neno supports the prefixing of namespaces. For example, <span id="S3.SS2.SSS1.p1.1.1" class="ltx_text ltx_font_typewriter">demo:Human</span> resolves to</p>
<table id="S3.Ex7" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S3.Ex7.m1.1" class="ltx_Math" alttext="\texttt{http://neno.lanl.gov/demo\#Human}." display="block"><semantics id="S3.Ex7.m1.1a"><mrow id="S3.Ex7.m1.1.2.2" xref="S3.Ex7.m1.1.1a.cmml"><mtext class="ltx_mathvariant_monospace" id="S3.Ex7.m1.1.1" xref="S3.Ex7.m1.1.1.cmml">http://neno.lanl.gov/demo#Human</mtext><mo lspace="0em" id="S3.Ex7.m1.1.2.2.1" xref="S3.Ex7.m1.1.1a.cmml">.</mo></mrow><annotation-xml encoding="MathML-Content" id="S3.Ex7.m1.1b"><ci id="S3.Ex7.m1.1.1a.cmml" xref="S3.Ex7.m1.1.2.2"><mtext class="ltx_mathvariant_monospace" id="S3.Ex7.m1.1.1.cmml" xref="S3.Ex7.m1.1.1">http://neno.lanl.gov/demo#Human</mtext></ci></annotation-xml><annotation encoding="application/x-tex" id="S3.Ex7.m1.1c">\texttt{http://neno.lanl.gov/demo\#Human}.</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
</div>
</section>
<section id="S3.SS2.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.2 </span>Datatypes</h4>

<div id="S3.SS2.SSS2.p1" class="ltx_para">
<p id="S3.SS2.SSS2.p1.1" class="ltx_p">Fhat is engineered to handle <span id="S3.SS2.SSS2.p1.1.1" class="ltx_text ltx_font_typewriter">xsd:anySimpleType</span> and provides specific support for any of its derived types ( ?). The XSD namespace maintains, amongst others: <span id="S3.SS2.SSS2.p1.1.2" class="ltx_text ltx_font_typewriter">xsd:string</span>, <span id="S3.SS2.SSS2.p1.1.3" class="ltx_text ltx_font_typewriter">xsd:double</span>, <span id="S3.SS2.SSS2.p1.1.4" class="ltx_text ltx_font_typewriter">xsd:integer</span>, <span id="S3.SS2.SSS2.p1.1.5" class="ltx_text ltx_font_typewriter">xsd:date</span>, etc. Example operations include,
<span id="S3.SS2.SSS2.p1.1.6" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS2.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

"neno"^^xsd:string + "fhat"^^xsd:string
"2007-11-30"^^xsd:date &lt; "2007-12-01"^^xsd:date
"1"^^xsd:integer - "0"^^xsd:integer

</pre>
<p id="S3.SS2.SSS2.p1.3" class="ltx_p">Neno has low-level support for high-level datatype manipulations such as string concatenation, data and time comparisons, date incrementing, etc. Exactly what operations are allowed with what datatypes will be discussed later when describing the Fhat instruction set.</p>
</div>
</section>
<section id="S3.SS2.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.3 </span>The <span id="S3.SS2.SSS3.1.1" class="ltx_text ltx_font_typewriter">this</span> Variable</h4>

<div id="S3.SS2.SSS3.p1" class="ltx_para">
<p id="S3.SS2.SSS3.p1.1" class="ltx_p">The <span id="S3.SS2.SSS3.p1.1.1" class="ltx_text ltx_font_typewriter">this</span> variable is used in many object-oriented languages to specify the field to be accessed or the method to be invoked. All methods inherently have <span id="S3.SS2.SSS3.p1.1.2" class="ltx_text ltx_font_typewriter">this</span> as a variable they can use. The same construct exists in Neno with no variation in meaning.</p>
</div>
</section>
<section id="S3.SS2.SSS4" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.4 </span>Field Cardinality</h4>

<div id="S3.SS2.SSS4.p1" class="ltx_para">
<p id="S3.SS2.SSS4.p1.1" class="ltx_p">While Neno is an object-oriented language, it is also a semantic network programming language. Neno is more in line with the concepts of RDF than it is with those of Java and C++. One of the major distinguishing features of an object in Neno is that objects can have multi-instance fields. This means that a single field (predicate) can have more than one value (object). For instance, in Java
<span id="S3.SS2.SSS4.p1.1.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS4.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

Human marko = new Human("Marko Rodriguez");
marko.setName("Marko Antonio Rodriguez");

</pre>
<p id="S3.SS2.SSS4.p1.3" class="ltx_p">will initially set the <span id="S3.SS2.SSS4.p1.3.1" class="ltx_text ltx_font_typewriter">hasName</span> field of the <span id="S3.SS2.SSS4.p1.3.2" class="ltx_text ltx_font_typewriter">Human</span> object referenced by the variable name <span id="S3.SS2.SSS4.p1.3.3" class="ltx_text ltx_font_typewriter">marko</span> to “Marko Rodriguez”. The invocation of the <span id="S3.SS2.SSS4.p1.3.4" class="ltx_text ltx_font_typewriter">setName</span> method of <span id="S3.SS2.SSS4.p1.3.5" class="ltx_text ltx_font_typewriter">marko</span> will replace “Marko Rodriguez” with “Marko Antonio Rodriguez”. Thus, the field <span id="S3.SS2.SSS4.p1.3.6" class="ltx_text ltx_font_typewriter">hasName</span> has a cardinality of 1. All fields in Java have a cardinality of 1 and are universally quantified for the specified class (though taxonomical subsumption is supported).</p>
</div>
<div id="S3.SS2.SSS4.p2" class="ltx_para">
<p id="S3.SS2.SSS4.p2.1" class="ltx_p">In Neno, it is possible for a field to have a cardinality greater than one. In Neno, when a class’ fields are declared, the cardinality specifier is used to denote how many properties of this type are allowed for an instance of this class. Thus, in the Neno code at the start of this section,
<span id="S3.SS2.SSS4.p2.1.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS4.p2.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

 xsd:string hasName[1];

</pre>
<p id="S3.SS2.SSS4.p2.3" class="ltx_p">states that any <span id="S3.SS2.SSS4.p2.3.1" class="ltx_text ltx_font_typewriter">Human</span> object must have one and only one field (property) called <span id="S3.SS2.SSS4.p2.3.2" class="ltx_text ltx_font_typewriter">hasName</span> and that <span id="S3.SS2.SSS4.p2.3.3" class="ltx_text ltx_font_typewriter">hasName</span> field points to some <span id="S3.SS2.SSS4.p2.3.4" class="ltx_text ltx_font_typewriter">xsd:string</span>. Therefore, it is illegal for the Fhat RVM to add a new <span id="S3.SS2.SSS4.p2.3.5" class="ltx_text ltx_font_typewriter">hasName</span> property to the class <span id="S3.SS2.SSS4.p2.3.6" class="ltx_text ltx_font_typewriter">marko</span>. The original property must be removed before the new property can be added. The general grammar for field restrictions in Neno is <span id="S3.SS2.SSS4.p2.3.7" class="ltx_text ltx_font_typewriter">[# (..(# | *))]</span>, where <span id="S3.SS2.SSS4.p2.3.8" class="ltx_text ltx_font_typewriter">#</span> refers to some integer value.</p>
</div>
<div id="S3.SS2.SSS4.p3" class="ltx_para">
<p id="S3.SS2.SSS4.p3.1" class="ltx_p">Neno does not adopt any of the OWL semantics regarding cardinality and “semantically distinct” resources. The <span id="S3.SS2.SSS4.p3.1.1" class="ltx_text ltx_font_typewriter">owl:sameAs</span> relationship between resources is not considered when determining the cardinality of a property and thus, only the explicit number of properties (explicit triples) of a particular type (predicate) are acknowledged by the NenoFhat compiler and Fhat RVM.</p>
</div>
</section>
<section id="S3.SS2.SSS5" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.5 </span>Handling Fields</h4>

<div id="S3.SS2.SSS5.p1" class="ltx_para">
<p id="S3.SS2.SSS5.p1.2" class="ltx_p">Neno provides the following field and local variable operators: <span id="S3.SS2.SSS5.p1.2.1" class="ltx_text ltx_font_typewriter">=+</span>, <span id="S3.SS2.SSS5.p1.2.2" class="ltx_text ltx_font_typewriter">=-</span>, <span id="S3.SS2.SSS5.p1.2.3" class="ltx_text ltx_font_typewriter">=/</span>, and <span id="S3.SS2.SSS5.p1.2.4" class="ltx_text ltx_font_typewriter">=</span>. These operators are called “set plus”, “set minus”, “set clear”, and “set”, respectively. The definition of these operators is made apparent through examples that demonstrate their use. For instance, from the class declarations above, the <span id="S3.SS2.SSS5.p1.2.5" class="ltx_text ltx_font_typewriter">Human</span> class has the field <span id="S3.SS2.SSS5.p1.2.6" class="ltx_text ltx_font_typewriter">hasFriend</span>. For the Java example, the <span id="S3.SS2.SSS5.p1.2.7" class="ltx_text ltx_font_typewriter">hasFriend</span> field can have more than one <span id="S3.SS2.SSS5.p1.2.8" class="ltx_text ltx_font_typewriter">Human</span> value only indirectly through the use of the <span id="S3.SS2.SSS5.p1.2.9" class="ltx_text ltx_font_typewriter">ArrayList&lt;Human&gt;</span> class. In Neno, no <span id="S3.SS2.SSS5.p1.2.10" class="ltx_text ltx_font_typewriter">ArrayList&lt;Human&gt;</span> is needed because a field can have a cardinality greater than 1. The cardinality specifier <span id="S3.SS2.SSS5.p1.2.11" class="ltx_text ltx_font_typewriter">[0..*]</span> states that there are no restrictions on the number of friends a <span id="S3.SS2.SSS5.p1.2.12" class="ltx_text ltx_font_typewriter">Human</span> can have. In order to add more friends to a <span id="S3.SS2.SSS5.p1.2.13" class="ltx_text ltx_font_typewriter">Human</span> object, the <span id="S3.SS2.SSS5.p1.2.14" class="ltx_text ltx_font_typewriter">=+</span> operator is used. If the <span id="S3.SS2.SSS5.p1.2.15" class="ltx_text ltx_font_typewriter">Human</span> instance has the URI <span id="S3.SS2.SSS5.p1.2.16" class="ltx_text ltx_font_typewriter">urn:uuid:2db4a1d2</span> and the provided <span id="S3.SS2.SSS5.p1.2.17" class="ltx_text ltx_font_typewriter">Human</span> argument has the URI <span id="S3.SS2.SSS5.p1.2.18" class="ltx_text ltx_font_typewriter">urn:uuid:47878dcc</span> then the <span id="S3.SS2.SSS5.p1.2.19" class="ltx_text ltx_font_typewriter">=+</span> operator instructs Fhat to execute
<span id="S3.SS2.SSS5.p1.2.20" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS5.p1.3" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

INSERT { &lt;urn:uuid:2db4a1d2&gt; &lt;demo:hasFriend&gt; &lt;urn:uuid:47878dcc&gt; .}

</pre>
<p id="S3.SS2.SSS5.p1.4" class="ltx_p">on the triple-store. On the other hand, if the <span id="S3.SS2.SSS5.p1.4.1" class="ltx_text ltx_font_typewriter">=</span> operator was used, then Fhat would issue the following commands to the triple-store:
<span id="S3.SS2.SSS5.p1.4.2" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS5.p1.5" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

DELETE { &lt;urn:uuid:2db4a1d2&gt; &lt;demo:hasFriend&gt; ?x .}
INSERT { &lt;urn:uuid:2db4a1d2&gt; &lt;demo:hasFriend&gt; &lt;urn:uuid:47878dcc&gt; .}

</pre>
<p id="S3.SS2.SSS5.p1.1" class="ltx_p">For a multi-instance field, the <math id="S3.SS2.SSS5.p1.1.m1.1" class="ltx_Math" alttext="=" display="inline"><semantics id="S3.SS2.SSS5.p1.1.m1.1a"><mo id="S3.SS2.SSS5.p1.1.m1.1.1" xref="S3.SS2.SSS5.p1.1.m1.1.1.cmml">=</mo><annotation-xml encoding="MathML-Content" id="S3.SS2.SSS5.p1.1.m1.1b"><eq id="S3.SS2.SSS5.p1.1.m1.1.1.cmml" xref="S3.SS2.SSS5.p1.1.m1.1.1"></eq></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.SSS5.p1.1.m1.1c">=</annotation></semantics></math> is a very destructive operator. For a <span id="S3.SS2.SSS5.p1.1.1" class="ltx_text ltx_font_typewriter">[0..1]</span> or <span id="S3.SS2.SSS5.p1.1.2" class="ltx_text ltx_font_typewriter">[1]</span> field, <span id="S3.SS2.SSS5.p1.1.3" class="ltx_text ltx_font_typewriter">=</span> behaves as one would expect in any other object-oriented language. Furthermore, for a <span id="S3.SS2.SSS5.p1.1.4" class="ltx_text ltx_font_typewriter">[0..1]</span> or <span id="S3.SS2.SSS5.p1.1.5" class="ltx_text ltx_font_typewriter">[1]</span> field, <span id="S3.SS2.SSS5.p1.1.6" class="ltx_text ltx_font_typewriter">=+</span> is not allowed as it will cause the insertion of more than one property of the same predicate.</p>
</div>
<div id="S3.SS2.SSS5.p2" class="ltx_para">
<p id="S3.SS2.SSS5.p2.1" class="ltx_p">In order to control the removal of fields from a multi-instance field, the <span id="S3.SS2.SSS5.p2.1.1" class="ltx_text ltx_font_typewriter">=-</span> and <span id="S3.SS2.SSS5.p2.1.2" class="ltx_text ltx_font_typewriter">=/</span> operators can be used. For example, suppose the following method declaration in Neno
<span id="S3.SS2.SSS5.p2.1.3" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS5.p2.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

makeEnemy(Human h) {
  this.hasFriends =- h;
}

</pre>
<p id="S3.SS2.SSS5.p2.3" class="ltx_p">The <span id="S3.SS2.SSS5.p2.3.1" class="ltx_text ltx_font_typewriter">makeEnemy</span> method will remove the <span id="S3.SS2.SSS5.p2.3.2" class="ltx_text ltx_font_typewriter">Human</span> object identified by the variable name <span id="S3.SS2.SSS5.p2.3.3" class="ltx_text ltx_font_typewriter">h</span> from the <span id="S3.SS2.SSS5.p2.3.4" class="ltx_text ltx_font_typewriter">hasFriend</span> fields. If the <span id="S3.SS2.SSS5.p2.3.5" class="ltx_text ltx_font_typewriter">h</span> variable is a reference to the URI <span id="S3.SS2.SSS5.p2.3.6" class="ltx_text ltx_font_typewriter">urn:uuid:4800e2c2</span>, then at the Fhat level, Fhat will execute the following command on the triple-store:
<span id="S3.SS2.SSS5.p2.3.7" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS5.p2.4" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

DELETE { &lt;urn:uuid:2db4a1d2&gt; &lt;demo:hasFriend&gt; &lt;urn:uuid:4800e2c2&gt; .}

</pre>
</div>
<div id="S3.SS2.SSS5.p3" class="ltx_para">
<p id="S3.SS2.SSS5.p3.1" class="ltx_p">Finally, assume that there is a rogue <span id="S3.SS2.SSS5.p3.1.1" class="ltx_text ltx_font_typewriter">Human</span> that wishes to have no friends at all. In order for this one man army to sever his ties, the <math id="S3.SS2.SSS5.p3.1.m1.1" class="ltx_Math" alttext="=/" display="inline"><semantics id="S3.SS2.SSS5.p3.1.m1.1a"><mrow id="S3.SS2.SSS5.p3.1.m1.1.1" xref="S3.SS2.SSS5.p3.1.m1.1.1.cmml"><mi id="S3.SS2.SSS5.p3.1.m1.1.1.2" xref="S3.SS2.SSS5.p3.1.m1.1.1.2.cmml"></mi><mo rspace="0em" id="S3.SS2.SSS5.p3.1.m1.1.1.1" xref="S3.SS2.SSS5.p3.1.m1.1.1.1.cmml">=</mo><mo lspace="0em" id="S3.SS2.SSS5.p3.1.m1.1.1.3" xref="S3.SS2.SSS5.p3.1.m1.1.1.3.cmml">/</mo></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.SSS5.p3.1.m1.1b"><apply id="S3.SS2.SSS5.p3.1.m1.1.1.cmml" xref="S3.SS2.SSS5.p3.1.m1.1.1"><eq id="S3.SS2.SSS5.p3.1.m1.1.1.1.cmml" xref="S3.SS2.SSS5.p3.1.m1.1.1.1"></eq><csymbol cd="latexml" id="S3.SS2.SSS5.p3.1.m1.1.1.2.cmml" xref="S3.SS2.SSS5.p3.1.m1.1.1.2">absent</csymbol><divide id="S3.SS2.SSS5.p3.1.m1.1.1.3.cmml" xref="S3.SS2.SSS5.p3.1.m1.1.1.3"></divide></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.SSS5.p3.1.m1.1c">=/</annotation></semantics></math> operator is used. Assume the following overloaded method declaration for a <span id="S3.SS2.SSS5.p3.1.2" class="ltx_text ltx_font_typewriter">Human</span>.
<span id="S3.SS2.SSS5.p3.1.3" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS5.p3.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

makeEnemy() {
  this.hasFriends =/;
}

</pre>
<p id="S3.SS2.SSS5.p3.3" class="ltx_p">The above statement statement would have Fhat execute the following delete command on the triple-store:
<span id="S3.SS2.SSS5.p3.3.1" class="ltx_text" style="font-size:70%;">
<span id="S3.SS2.SSS5.p3.3.1.1" class="ltx_text" style="font-size:114%;"></span></span></p>
<pre id="S3.SS2.SSS5.p3.4" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

DELETE { &lt;urn:uuid:2db4a1d2&gt; &lt;demo:hasFriend&gt; ?human }

</pre>
</div>
</section>
<section id="S3.SS2.SSS6" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.6 </span>Field Querying</h4>

<div id="S3.SS2.SSS6.p1" class="ltx_para">
<p id="S3.SS2.SSS6.p1.5" class="ltx_p">In many cases, a field (i.e. property) will have many instances. In computer programming terms, fields can be thought of as arrays. However, these “arrays” are not objects, but simply greater than one cardinality fields. In Java, arrays are objects and high-level array objects like the <span id="S3.SS2.SSS6.p1.5.1" class="ltx_text ltx_font_typewriter">java.util.ArrayList</span> provide functions to search an array. In Neno, there are no methods that support such behaviors since fields are not objects. Instead, Neno provides language constructs that support field querying. For example, suppose the following method
<span id="S3.SS2.SSS6.p1.5.2" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS6.p1.6" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

boolean isFriend(Human unknown) {
  if(this.hasFriend =? unknown) {
    return true;
  }
  else {
   return false;
  }
 }
</pre>
<p id="S3.SS2.SSS6.p1.4" class="ltx_p">In the above <span id="S3.SS2.SSS6.p1.4.5" class="ltx_text ltx_font_typewriter">isFriend</span> method, the provided <span id="S3.SS2.SSS6.p1.4.6" class="ltx_text ltx_font_typewriter">Human</span> argument referenced by the variable name <span id="S3.SS2.SSS6.p1.4.7" class="ltx_text ltx_font_typewriter">unknown</span> is checked against all the <span id="S3.SS2.SSS6.p1.4.8" class="ltx_text ltx_font_typewriter">hasFriend</span> fields. Again, the <span id="S3.SS2.SSS6.p1.4.9" class="ltx_text ltx_font_typewriter">owl:sameAs</span> property is not respected and thus, “sameness” is determined by exact URIs. The <span id="S3.SS2.SSS6.p1.4.10" class="ltx_text ltx_font_typewriter">=?</span> operator is a conditional operator and thus, always returns either <span id="S3.SS2.SSS6.p1.2.2" class="ltx_text ltx_font_typewriter">"true"<sup id="S3.SS2.SSS6.p1.2.2.1" class="ltx_sup"><span id="S3.SS2.SSS6.p1.2.2.1.1" class="ltx_text ltx_font_serif">∧</span></sup><sup id="S3.SS2.SSS6.p1.2.2.2" class="ltx_sup"><span id="S3.SS2.SSS6.p1.2.2.2.1" class="ltx_text ltx_font_serif">∧</span></sup>xsd:boolean</span> or <span id="S3.SS2.SSS6.p1.4.4" class="ltx_text ltx_font_typewriter">"false"<sup id="S3.SS2.SSS6.p1.4.4.1" class="ltx_sup"><span id="S3.SS2.SSS6.p1.4.4.1.1" class="ltx_text ltx_font_serif">∧</span></sup><sup id="S3.SS2.SSS6.p1.4.4.2" class="ltx_sup"><span id="S3.SS2.SSS6.p1.4.4.2.1" class="ltx_text ltx_font_serif">∧</span></sup>xsd:boolean</span>. At the Fhat level, if <span id="S3.SS2.SSS6.p1.4.11" class="ltx_text ltx_font_typewriter">this</span> references the UUID <span id="S3.SS2.SSS6.p1.4.12" class="ltx_text ltx_font_typewriter">urn:uuid:2d386232</span> and <span id="S3.SS2.SSS6.p1.4.13" class="ltx_text ltx_font_typewriter">unknown</span> references <span id="S3.SS2.SSS6.p1.4.14" class="ltx_text ltx_font_typewriter">urn:uuid:75e05c12</span>, then the Fhat RVM executes the following query on the triple-store:
<span id="S3.SS2.SSS6.p1.4.15" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS6.p1.7" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

ASK { &lt;urn:uuid:2d386232&gt; &lt;demo:hasFriend&gt;  &lt;urn:uuid:75e05c12&gt; . }

</pre>
</div>
<div id="S3.SS2.SSS6.p2" class="ltx_para">
<p id="S3.SS2.SSS6.p2.1" class="ltx_p">Similarly, imagine the following method,
<span id="S3.SS2.SSS6.p2.1.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS6.p2.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

boolean isFriendByName(Human unknown) {
  if(this.hasFriend.hasName =? unknown.hasName) {
    return true;
  }
  else {
   return false;
  }
 }
</pre>
<p id="S3.SS2.SSS6.p2.3" class="ltx_p">Assuming the same UUID references for <span id="S3.SS2.SSS6.p2.3.1" class="ltx_text ltx_font_typewriter">this</span> and <span id="S3.SS2.SSS6.p2.3.2" class="ltx_text ltx_font_typewriter">unknown</span> from previous examples, the <span id="S3.SS2.SSS6.p2.3.3" class="ltx_text ltx_font_typewriter">=?</span> operation would have the Fhat execute the following query on the RDF network
<span id="S3.SS2.SSS6.p2.3.4" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS6.p2.4" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

ASK { &lt;urn:uuid:2d386232&gt; &lt;demo:hasFriend&gt;  ?x .
      ?x &lt;demo:hasName&gt; ?y .
      &lt;urn:uuid:75e05c12&gt; &lt;demo:hasName&gt; ?y }

</pre>
</div>
<div id="S3.SS2.SSS6.p3" class="ltx_para">
<p id="S3.SS2.SSS6.p3.1" class="ltx_p">Again, there is no reasoning involved in any of these triple-store operations; only “raw” triple and URI/literal matching is used.</p>
</div>
</section>
<section id="S3.SS2.SSS7" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.7 </span>Looping and Conditionals</h4>

<div id="S3.SS2.SSS7.p1" class="ltx_para">
<p id="S3.SS2.SSS7.p1.1" class="ltx_p">Looping and conditionals are nearly identical to the Java language. In Neno, there exists the <span id="S3.SS2.SSS7.p1.1.1" class="ltx_text ltx_font_typewriter">for</span>, <span id="S3.SS2.SSS7.p1.1.2" class="ltx_text ltx_font_typewriter">while</span>, and <span id="S3.SS2.SSS7.p1.1.3" class="ltx_text ltx_font_typewriter">if/else</span> constructs. For example, a <span id="S3.SS2.SSS7.p1.1.4" class="ltx_text ltx_font_typewriter">for</span> statement is
<span id="S3.SS2.SSS7.p1.1.5" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS7.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

for(xsd:integer i = "0"^^xsd:integer; i&lt;"10"^^xsd:integer; i++)
{ /* for block */ }

</pre>
<p id="S3.SS2.SSS7.p1.3" class="ltx_p">a <span id="S3.SS2.SSS7.p1.3.1" class="ltx_text ltx_font_typewriter">while</span> statement is
<span id="S3.SS2.SSS7.p1.3.2" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS7.p1.4" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

while(xsd:integer i &lt; "10"^^xsd:integer)
  { /* while block */ }

</pre>
<p id="S3.SS2.SSS7.p1.5" class="ltx_p">and an <span id="S3.SS2.SSS7.p1.5.1" class="ltx_text ltx_font_typewriter">if/else</span> statement is
<span id="S3.SS2.SSS7.p1.5.2" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS7.p1.6" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

if(xsd:integer i &lt; "10"^^xsd:integer)
  { /* if block */ }
  { /* else block */}

</pre>
</div>
<div id="S3.SS2.SSS7.p2" class="ltx_para">
<p id="S3.SS2.SSS7.p2.1" class="ltx_p">It is important to note that these statements need not have the literal type specifier (e.g. <span id="S3.SS2.SSS7.p2.1.1" class="ltx_text ltx_font_typewriter">xsd:integer</span>) on every hardcoded literal. The literal type can be inferred from its context and thus, is automatically added by the compiler. For example, since <span id="S3.SS2.SSS7.p2.1.2" class="ltx_text ltx_font_typewriter">i</span> is an <span id="S3.SS2.SSS7.p2.1.3" class="ltx_text ltx_font_typewriter">xsd:integer</span>, it is assumed that <math id="S3.SS2.SSS7.p2.1.m1.1" class="ltx_Math" alttext="10" display="inline"><semantics id="S3.SS2.SSS7.p2.1.m1.1a"><mn id="S3.SS2.SSS7.p2.1.m1.1.1" xref="S3.SS2.SSS7.p2.1.m1.1.1.cmml">10</mn><annotation-xml encoding="MathML-Content" id="S3.SS2.SSS7.p2.1.m1.1b"><cn type="integer" id="S3.SS2.SSS7.p2.1.m1.1.1.cmml" xref="S3.SS2.SSS7.p2.1.m1.1.1">10</cn></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.SSS7.p2.1.m1.1c">10</annotation></semantics></math> is also.</p>
</div>
</section>
<section id="S3.SS2.SSS8" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.8 </span>Field Looping</h4>

<div id="S3.SS2.SSS8.p1" class="ltx_para">
<p id="S3.SS2.SSS8.p1.1" class="ltx_p">In many cases it is desirable to loop through all the resources of a field for the purposes of searching or for manipulating each resource. For instance, suppose the following <span id="S3.SS2.SSS8.p1.1.1" class="ltx_text ltx_font_typewriter">Human</span> method:
<span id="S3.SS2.SSS8.p1.1.2" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS8.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

namelessFaces() {
  for(Human h : this.hasFriend) {
    h.hasName = "..."^^xsd:string;
  }
  for(xsd:integer i=0; i&lt;this.hasFriend*; i++) {
    Human h = this.hasFriend[i];
    h.hasName = "."^^xsd:string;
  }
 }

</pre>
<p id="S3.SS2.SSS8.p1.3" class="ltx_p">The above <span id="S3.SS2.SSS8.p1.3.1" class="ltx_text ltx_font_typewriter">namelessFaces</span> method demonstrates two types of field looping mechanisms offered by Neno. The first is analogous to the Java 1.5 language specification. With the first for loop, the variable <span id="S3.SS2.SSS8.p1.3.2" class="ltx_text ltx_font_typewriter">h</span> is set to a single <span id="S3.SS2.SSS8.p1.3.3" class="ltx_text ltx_font_typewriter">hasFriend</span> of <span id="S3.SS2.SSS8.p1.3.4" class="ltx_text ltx_font_typewriter">this</span>. The second for loop uses the index <span id="S3.SS2.SSS8.p1.3.5" class="ltx_text ltx_font_typewriter">i</span> that goes from index 0 to the size of the “array” (<span id="S3.SS2.SSS8.p1.3.6" class="ltx_text ltx_font_typewriter">this.hasFriend*</span>). The <span id="S3.SS2.SSS8.p1.3.7" class="ltx_text ltx_font_typewriter">*</span> notation in this context returns the number of <span id="S3.SS2.SSS8.p1.3.8" class="ltx_text ltx_font_typewriter">hasFriend</span> properties of the <span id="S3.SS2.SSS8.p1.3.9" class="ltx_text ltx_font_typewriter">this</span> object. In other words <span id="S3.SS2.SSS8.p1.3.10" class="ltx_text ltx_font_typewriter">*</span> returns the cardinality of the <span id="S3.SS2.SSS8.p1.3.11" class="ltx_text ltx_font_typewriter">this.hasFriend</span> field.</p>
</div>
<div id="S3.SS2.SSS8.p2" class="ltx_para">
<p id="S3.SS2.SSS8.p2.1" class="ltx_p">Finally, as field values are not stored in a vector, but instead as an unordered set, the field “arrays” in Neno are not guaranteed to be ordered. Thus, <span id="S3.SS2.SSS8.p2.1.1" class="ltx_text ltx_font_typewriter">this.hasFriend[1]</span> may not be the same value later in the code. Ordering is dependent upon the triple-store’s indexing algorithm and stability of a particular order is dependent upon how often re-indexing occurs in the triple-store. It is worth noting that higher-order classes can be created such as specialized <span id="S3.SS2.SSS8.p2.1.2" class="ltx_text ltx_font_typewriter">rdf:Seq</span> and <span id="S3.SS2.SSS8.p2.1.3" class="ltx_text ltx_font_typewriter">rdf:List</span> classes to provided ordered support for arrays.</p>
</div>
</section>
<section id="S3.SS2.SSS9" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.9 </span>Type Checking</h4>

<div id="S3.SS2.SSS9.p1" class="ltx_para">
<p id="S3.SS2.SSS9.p1.1" class="ltx_p">The <span id="S3.SS2.SSS9.p1.1.1" class="ltx_text ltx_font_typewriter">typeof</span> operator can be used to determine the class type of a URI. For instance, the following statement,
<span id="S3.SS2.SSS9.p1.1.2" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS9.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

xsd:boolean isType = urn:uuid:2db4a1d2 typeof Human

</pre>
<p id="S3.SS2.SSS9.p1.3" class="ltx_p">would return <span id="S3.SS2.SSS9.p1.3.1" class="ltx_text ltx_font_typewriter">true</span> if <span id="S3.SS2.SSS9.p1.3.2" class="ltx_text ltx_font_typewriter">urn:uuid:2db4a1d2</span> is <span id="S3.SS2.SSS9.p1.3.3" class="ltx_text ltx_font_typewriter">rdf:type</span> <span id="S3.SS2.SSS9.p1.3.4" class="ltx_text ltx_font_typewriter">Human</span> or <span id="S3.SS2.SSS9.p1.3.5" class="ltx_text ltx_font_typewriter">rdf:type</span> of some class that is an <span id="S3.SS2.SSS9.p1.3.6" class="ltx_text ltx_font_typewriter">rdfs:subClassOf</span> <span id="S3.SS2.SSS9.p1.3.7" class="ltx_text ltx_font_typewriter">Human</span>. Also,
<span id="S3.SS2.SSS9.p1.3.8" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS9.p1.4" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

xsd:boolean isType = urn:uuid:2db4a1d2 typeof rdfs:Resource

</pre>
<p id="S3.SS2.SSS9.p1.5" class="ltx_p">always returns <span id="S3.SS2.SSS9.p1.5.1" class="ltx_text ltx_font_typewriter">true</span>. Thus, RDFS subsumption semantics are respected and thus, Neno respects the subclassing semantics employed by modern objected-oriented languages. Similarly the <span id="S3.SS2.SSS9.p1.5.2" class="ltx_text ltx_font_typewriter">typeOf?</span> operator returns the type of the resource. For instance,
<span id="S3.SS2.SSS9.p1.5.3" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS9.p1.6" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

xsd:anyURI type = urn:uuid:2db4a1d2 typeof?

</pre>
<p id="S3.SS2.SSS9.p1.7" class="ltx_p">returns <span id="S3.SS2.SSS9.p1.7.1" class="ltx_text ltx_font_typewriter">http://neno.lanl.gov/demo#Human</span>.</p>
</div>
</section>
<section id="S3.SS2.SSS10" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.10 </span>Inverse Field Referencing</h4>

<div id="S3.SS2.SSS10.p1" class="ltx_para">
<p id="S3.SS2.SSS10.p1.1" class="ltx_p">In object-oriented languages the “dot” operator is used to access a method or field of an object. For instance, in <span id="S3.SS2.SSS10.p1.1.1" class="ltx_text ltx_font_typewriter">this.hasName</span>, on the left of the “dot” is the object and on the right of the “dot” is the field. Whether the right hand side of the operator is a field or method can be deduced by the compiler from its context. If <span id="S3.SS2.SSS10.p1.1.2" class="ltx_text ltx_font_typewriter">this</span> resolves to the URI <span id="S3.SS2.SSS10.p1.1.3" class="ltx_text ltx_font_typewriter">urn:uuid:2db4a1d2</span>, then the following Neno code
<span id="S3.SS2.SSS10.p1.1.4" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS10.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

Human h[0..*] = this.hasFriend;

</pre>
<p id="S3.SS2.SSS10.p1.3" class="ltx_p">would instruct Fhat to execute the following query:
<span id="S3.SS2.SSS10.p1.3.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS10.p1.4" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

SELECT ?h
  WHERE { &lt;urn:uuid:2db4a1d2&gt; &lt;demo:hasFriend&gt; ?h . }

</pre>
<p id="S3.SS2.SSS10.p1.5" class="ltx_p">According to the previous query, everything that binds to <span id="S3.SS2.SSS10.p1.5.1" class="ltx_text ltx_font_typewriter">?h</span> will be set to the variable <span id="S3.SS2.SSS10.p1.5.2" class="ltx_text ltx_font_typewriter">h</span>. The above query says “locate all <span id="S3.SS2.SSS10.p1.5.3" class="ltx_text ltx_font_typewriter">Human</span> <span id="S3.SS2.SSS10.p1.5.4" class="ltx_text ltx_font_typewriter">hasFriend</span>s of <span id="S3.SS2.SSS10.p1.5.5" class="ltx_text ltx_font_typewriter">this</span> object.” However, Neno provides another concept not found in other object-oriented languages called the “dot dot” operator. The “dot dot” operator provides support for what is called inverse field referencing (and inverse method invocation discussed next). Assume the following line in some method of some class,
<span id="S3.SS2.SSS10.p1.5.6" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS10.p1.6" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

Human h[0..*] = this..hasFriend;

</pre>
<p id="S3.SS2.SSS10.p1.7" class="ltx_p">The above statement says, “locate all <span id="S3.SS2.SSS10.p1.7.1" class="ltx_text ltx_font_typewriter">Human</span>s that have <span id="S3.SS2.SSS10.p1.7.2" class="ltx_text ltx_font_typewriter">this</span> object as their <span id="S3.SS2.SSS10.p1.7.3" class="ltx_text ltx_font_typewriter">hasFriend</span>.” At the Fhat level, Fhat executes the following query on the triple-store:
<span id="S3.SS2.SSS10.p1.7.4" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS10.p1.8" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

SELECT ?h
  WHERE { ?h &lt;demo:hasFriend&gt; &lt;urn:uuid:2db4a1d2&gt; .}

</pre>
<p id="S3.SS2.SSS10.p1.9" class="ltx_p">Furthermore, if the statement is
<span id="S3.SS2.SSS10.p1.9.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS10.p1.10" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

Human h[0..3] = this..hasFriend;

</pre>
<p id="S3.SS2.SSS10.p1.11" class="ltx_p">Fhat would execute:
<span id="S3.SS2.SSS10.p1.11.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS10.p1.12" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

SELECT ?h
  WHERE { ?h &lt;demo:hasFriend&gt; &lt;urn:uuid:2db4a1d2&gt; .} LIMIT 3

</pre>
</div>
</section>
<section id="S3.SS2.SSS11" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.11 </span>Inverse Method Invocation</h4>

<div id="S3.SS2.SSS11.p1" class="ltx_para">
<p id="S3.SS2.SSS11.p1.1" class="ltx_p">Like inverse field referencing, inverse method invocation is supported by Neno. Inverse method invocation will invoke all the methods that meet a particular requirement. For instance,
<span id="S3.SS2.SSS11.p1.1.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS11.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

this..hasFriend.makeEnemy(this);

</pre>
<p id="S3.SS2.SSS11.p1.3" class="ltx_p">will ensure that all objects that have <span id="S3.SS2.SSS11.p1.3.1" class="ltx_text ltx_font_typewriter">this</span> as their friend are no longer friends with <span id="S3.SS2.SSS11.p1.3.2" class="ltx_text ltx_font_typewriter">this</span>.</p>
</div>
</section>
<section id="S3.SS2.SSS12" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.12 </span>Variable Scoping</h4>

<div id="S3.SS2.SSS12.p1" class="ltx_para">
<p id="S3.SS2.SSS12.p1.1" class="ltx_p">Variable scoping in Neno is equivalent to Java. For example, in
<span id="S3.SS2.SSS12.p1.1.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS12.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

xsd:integer a = "11"^^xsd:integer;
if(a &lt; "10"^^xsd:integer) {
  xsd:integer b = "2"^^xsd:integer;
}
else {
  xsd:integer c = "3"^^xsd:integer;
}

</pre>
<p id="S3.SS2.SSS12.p1.3" class="ltx_p">the true and false block of the <span id="S3.SS2.SSS12.p1.3.1" class="ltx_text ltx_font_typewriter">if</span> statement can read the variable <span id="S3.SS2.SSS12.p1.3.2" class="ltx_text ltx_font_typewriter">a</span>, but the true block can not read the <span id="S3.SS2.SSS12.p1.3.3" class="ltx_text ltx_font_typewriter">c</span> in the false block and the false block can not read the <span id="S3.SS2.SSS12.p1.3.4" class="ltx_text ltx_font_typewriter">b</span> in the true block. Also, methods are out of scope from one another. The only way methods communicate are through parameter passing, return values, and object manipulations.</p>
</div>
</section>
<section id="S3.SS2.SSS13" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.13 </span>Constructors and Destructors</h4>

<div id="S3.SS2.SSS13.p1" class="ltx_para">
<p id="S3.SS2.SSS13.p1.1" class="ltx_p">Constructors and destructors are used in object-oriented languages to create and destroy object, respectively. The concept of a constructor in Neno is similar to that of Java and C++. The concept of a destructor does not exist in Java, but does in C++. It is very important in Neno to provide the programmer an explicit way of performing object destruction. Again, unlike Java, Neno is intended to be used on a persistent semantic network substrate. Thus, when a Fhat stops executing or an object is no longer accessible by a Fhat, that object should not be automatically removed. In short, Fhat does not provide automatic garbage collection ( ?). It is the role of the programmer to explicitly remove all unwanted objects from the RDF network.</p>
</div>
<div id="S3.SS2.SSS13.p2" class="ltx_para">
<p id="S3.SS2.SSS13.p2.1" class="ltx_p">In order to create a new object, the constructor of a class is called using the <span id="S3.SS2.SSS13.p2.1.1" class="ltx_text ltx_font_typewriter">new</span> operator. For example,
<span id="S3.SS2.SSS13.p2.1.2" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS13.p2.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

Human marko = new Human("Marko"^^xsd:string);

</pre>
<p id="S3.SS2.SSS13.p2.3" class="ltx_p">will generate a sub-network in the RDF network equivalent to Figure <a href="#S3.F4" title="Figure 4 ‣ 3.2.13 Constructors and Destructors ‣ 3.2 Class Declarations in Neno Source Code ‣ 3 The Neno Language ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>.</p>
</div>
<figure id="S3.F4" class="ltx_figure"><img src="/html/0704.3395/assets/x4.png" id="S3.F4.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="403" height="181" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 4: </span>A Fhat instance maintains a variable reference to an object.</figcaption>
</figure>
<div id="S3.SS2.SSS13.p3" class="ltx_para">
<p id="S3.SS2.SSS13.p3.1" class="ltx_p">The algorithm by which Fhat creates the RDF sub-network will be discussed in the next section. For now, understand that in the variable environment of a Fhat instance there exists a variable named <span id="S3.SS2.SSS13.p3.1.1" class="ltx_text ltx_font_typewriter">marko</span> that points to the newly created <span id="S3.SS2.SSS13.p3.1.2" class="ltx_text ltx_font_typewriter">Human</span> instance (e.g. <math id="S3.SS2.SSS13.p3.1.m1.3" class="ltx_Math" alttext="\langle\texttt{marko},\texttt{rdf:type},\texttt{Human}\rangle" display="inline"><semantics id="S3.SS2.SSS13.p3.1.m1.3a"><mrow id="S3.SS2.SSS13.p3.1.m1.3.4.2" xref="S3.SS2.SSS13.p3.1.m1.3.4.1.cmml"><mo stretchy="false" id="S3.SS2.SSS13.p3.1.m1.3.4.2.1" xref="S3.SS2.SSS13.p3.1.m1.3.4.1.cmml">⟨</mo><mtext class="ltx_mathvariant_monospace" id="S3.SS2.SSS13.p3.1.m1.1.1" xref="S3.SS2.SSS13.p3.1.m1.1.1a.cmml">marko</mtext><mo id="S3.SS2.SSS13.p3.1.m1.3.4.2.2" xref="S3.SS2.SSS13.p3.1.m1.3.4.1.cmml">,</mo><mtext class="ltx_mathvariant_monospace" id="S3.SS2.SSS13.p3.1.m1.2.2" xref="S3.SS2.SSS13.p3.1.m1.2.2a.cmml">rdf:type</mtext><mo id="S3.SS2.SSS13.p3.1.m1.3.4.2.3" xref="S3.SS2.SSS13.p3.1.m1.3.4.1.cmml">,</mo><mtext class="ltx_mathvariant_monospace" id="S3.SS2.SSS13.p3.1.m1.3.3" xref="S3.SS2.SSS13.p3.1.m1.3.3a.cmml">Human</mtext><mo stretchy="false" id="S3.SS2.SSS13.p3.1.m1.3.4.2.4" xref="S3.SS2.SSS13.p3.1.m1.3.4.1.cmml">⟩</mo></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.SSS13.p3.1.m1.3b"><list id="S3.SS2.SSS13.p3.1.m1.3.4.1.cmml" xref="S3.SS2.SSS13.p3.1.m1.3.4.2"><ci id="S3.SS2.SSS13.p3.1.m1.1.1a.cmml" xref="S3.SS2.SSS13.p3.1.m1.1.1"><mtext class="ltx_mathvariant_monospace" id="S3.SS2.SSS13.p3.1.m1.1.1.cmml" xref="S3.SS2.SSS13.p3.1.m1.1.1">marko</mtext></ci><ci id="S3.SS2.SSS13.p3.1.m1.2.2a.cmml" xref="S3.SS2.SSS13.p3.1.m1.2.2"><mtext class="ltx_mathvariant_monospace" id="S3.SS2.SSS13.p3.1.m1.2.2.cmml" xref="S3.SS2.SSS13.p3.1.m1.2.2">rdf:type</mtext></ci><ci id="S3.SS2.SSS13.p3.1.m1.3.3a.cmml" xref="S3.SS2.SSS13.p3.1.m1.3.3"><mtext class="ltx_mathvariant_monospace" id="S3.SS2.SSS13.p3.1.m1.3.3.cmml" xref="S3.SS2.SSS13.p3.1.m1.3.3">Human</mtext></ci></list></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.SSS13.p3.1.m1.3c">\langle\texttt{marko},\texttt{rdf:type},\texttt{Human}\rangle</annotation></semantics></math>).</p>
</div>
<div id="S3.SS2.SSS13.p4" class="ltx_para">
<p id="S3.SS2.SSS13.p4.1" class="ltx_p">A destructor will instruct Fhat to destroy an object. A destructor is specified in the class declaration. For instance, suppose the following specification for <span id="S3.SS2.SSS13.p4.1.1" class="ltx_text ltx_font_typewriter">demo:Human</span>:
<span id="S3.SS2.SSS13.p4.1.2" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS13.p4.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

Thing Human {
  string hasName[1];
  Human hasFriend[0..*];

  !Human(string n) {
    this.hasName = n;
  }

  ~Human() {
    this.hasName =/
    this.hasFriend =/
    this..hasFriend =/
  }
}

</pre>
<p id="S3.SS2.SSS13.p4.3" class="ltx_p">In the above class declaration <span id="S3.SS2.SSS13.p4.3.1" class="ltx_text ltx_font_typewriter">!Human(string n)</span> is a constructor and <code id="S3.SS2.SSS13.p4.3.2" class="ltx_verbatim ltx_font_typewriter">~</code><span id="S3.SS2.SSS13.p4.3.3" class="ltx_text ltx_font_typewriter">Human()</span> is a destructor. A destructor is called using the <span id="S3.SS2.SSS13.p4.3.4" class="ltx_text ltx_font_typewriter">delete</span> operator. For instance,
<span id="S3.SS2.SSS13.p4.3.5" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS13.p4.4" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

delete marko;

</pre>
<p id="S3.SS2.SSS13.p4.5" class="ltx_p">calls <span id="S3.SS2.SSS13.p4.5.1" class="ltx_text ltx_font_typewriter">marko</span>’s <code id="S3.SS2.SSS13.p4.5.2" class="ltx_verbatim ltx_font_typewriter">~</code><span id="S3.SS2.SSS13.p4.5.3" class="ltx_text ltx_font_typewriter">Human()</span> destructor.</p>
</div>
<div id="S3.SS2.SSS13.p5" class="ltx_para">
<p id="S3.SS2.SSS13.p5.1" class="ltx_p">A class can only have at most one destructor and the destructor takes no arguments. The <code id="S3.SS2.SSS13.p5.1.1" class="ltx_verbatim ltx_font_typewriter">~</code><span id="S3.SS2.SSS13.p5.1.2" class="ltx_text ltx_font_typewriter">Human()</span> destructor removes the reference to the object’s name, removes all the references to the object’s friends, and removes all <span id="S3.SS2.SSS13.p5.1.3" class="ltx_text ltx_font_typewriter">hasFriend</span> references to that object. Thus, if the <span id="S3.SS2.SSS13.p5.1.4" class="ltx_text ltx_font_typewriter">Human</span> object has the URI <span id="S3.SS2.SSS13.p5.1.5" class="ltx_text ltx_font_typewriter">urn:uuid:55b2a3b0</span>, Fhat would execute the following commands on the triple-store:
<span id="S3.SS2.SSS13.p5.1.6" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS13.p5.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

DELETE { &lt;urn:uuid:55b2a3b0&gt; &lt;demo:hasName&gt; ?name .}
DELETE { &lt;urn:uuid:55b2a3b0&gt; &lt;demo:hasFriend&gt; ?human .}
DELETE { ?human &lt;demo:hasFriend&gt; &lt;urn:uuid:55b2a3b0&gt; .}

</pre>
<p id="S3.SS2.SSS13.p5.3" class="ltx_p">Behind the scenes, Fhat would also remove all the method references of <span id="S3.SS2.SSS13.p5.3.1" class="ltx_text ltx_font_typewriter">urn:uuid:55b2a3b0</span>, internal variable references to <span id="S3.SS2.SSS13.p5.3.2" class="ltx_text ltx_font_typewriter">urn:uuid:55b2a3b0</span>, and the <span id="S3.SS2.SSS13.p5.3.3" class="ltx_text ltx_font_typewriter">rdf:type</span> relationships that relate the object to the ontological-layer. When an object is properly destroyed, only its instance is removed from the RDF network. The object’s class specification still exists in the ontological-layer.</p>
</div>
</section>
<section id="S3.SS2.SSS14" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">3.2.14 </span>General Query</h4>

<div id="S3.SS2.SSS14.p1" class="ltx_para">
<p id="S3.SS2.SSS14.p1.1" class="ltx_p">In many instances, Fhat will not have a reference to a particular object. Again, the environment anticipated is one in which objects persist in the RDF network. Thus, when code is executed, it is necessary to locate the URI of a particular object for processing. In order to make this easy for the programmer, a query operator is defined called the “network query” operator and is denoted by the symbol <span id="S3.SS2.SSS14.p1.1.1" class="ltx_text ltx_font_typewriter">&lt;?</span>. For example,
<span id="S3.SS2.SSS14.p1.1.2" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS2.SSS14.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

xsd:string x = "Marko Antonio Rodriguez"^^xsd:string;
xsd:string query =
   "SELECT ?x WHERE { ?x &lt;demo:hasName&gt; &lt;" + x + "&gt; }
     LIMIT 1"^^xsd:string;
Human h[0..1] &lt;? query;

</pre>
<p id="S3.SS2.SSS14.p1.3" class="ltx_p">will query the RDF network for at most one <span id="S3.SS2.SSS14.p1.3.1" class="ltx_text ltx_font_typewriter">Human</span> named “Marko Antonio Rodriguez”. Note that three statements above could have been written as one. However, to demonstrate string concatenation and variable use, three were used.</p>
</div>
</section>
</section>
<section id="S3.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.3 </span>Starting a Program in Neno</h3>

<div id="S3.SS3.p1" class="ltx_para">
<p id="S3.SS3.p1.1" class="ltx_p">In Neno, there are no static methods. Thus, there does not exist something like the <span id="S3.SS3.p1.1.1" class="ltx_text ltx_font_typewriter">public static void main(String[] args)</span> method in Java. Instead, Fhat is provided a class URI and a method for that class that takes no arguments. The class is automatically instantiated by Fhat and the specified no-argument method is invoked. For example, if Fhat is pointed to the following <span id="S3.SS3.p1.1.2" class="ltx_text ltx_font_typewriter">Test</span> class and <span id="S3.SS3.p1.1.3" class="ltx_text ltx_font_typewriter">main</span> method, then the <span id="S3.SS3.p1.1.4" class="ltx_text ltx_font_typewriter">main</span> method creates a <span id="S3.SS3.p1.1.5" class="ltx_text ltx_font_typewriter">Human</span>, changes its name, then exits. When <span id="S3.SS3.p1.1.6" class="ltx_text ltx_font_typewriter">main</span> exits, Fhat halts.
<span id="S3.SS3.p1.1.7" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS3.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

owl:Thing demo:Test {
  main() {
    demo:Human h = new Human("Marko Rodriguez");
    h.setName("Marko Antonio Rodriguez");
  }
}

</pre>
</div>
</section>
<section id="S3.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.4 </span>Typical Use Case</h3>

<div id="S3.SS4.p1" class="ltx_para">
<p id="S3.SS4.p1.1" class="ltx_p">This section describes how a developer would typically use the Neno/Fhat environment. The terminal commands below ensure that the NenoFhat compiler translates Neno source code to a Fhat OWL API, loads the Fhat OWL API into the triple-store, instantiates a Fhat RVM, and points the RVM to the <span id="S3.SS4.p1.1.1" class="ltx_text ltx_font_typewriter">demo:Test</span> class with a <span id="S3.SS4.p1.1.2" class="ltx_text ltx_font_typewriter">main</span> method. Note that the third command is broken into four lines for display purposes. Do not assume that there is a newline character at the end of the first three lines of the third statement.
<span id="S3.SS4.p1.1.3" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS4.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

&gt; nenofhat Human.neno -o ntriple -t http://www.triplestore.net/sparql
&gt; nenofhat Test.neno -o xml -t http://www.triplestore.net/sparql
&gt; fhat -vmc http://neno.lanl.gov/neno#Fhat
       -c http://neno.lanl.gov/neno/demo#Test
       -cm main
       -t http://www.triplestore.net/sparql

</pre>
<p id="S3.SS4.p1.3" class="ltx_p">The first terminal command compiles the <span id="S3.SS4.p1.3.1" class="ltx_text ltx_font_typewriter">Human.neno</span> source code into a Fhat OWL API represented in N-TRIPLE format and then inserts the <span id="S3.SS4.p1.3.2" class="ltx_text ltx_font_typewriter">Human.ntriple</span> triples into the triple-store pointed to by the “-t” URL. The second terminal command compiles the <span id="S3.SS4.p1.3.3" class="ltx_text ltx_font_typewriter">Test.neno</span> source code and generates a Fhat OWL API in RDF/XML called <span id="S3.SS4.p1.3.4" class="ltx_text ltx_font_typewriter">Test.xml</span>. That RDF/XML file is then loaded into the triple-store. The <span id="S3.SS4.p1.3.5" class="ltx_text ltx_font_typewriter">nenofhat</span> compiler can produce any of the popular RDF syntaxes. While in most cases, one or another is chosen, two different syntaxes are shown to demonstrate what is possible with the compiler. Finally, a <span id="S3.SS4.p1.3.6" class="ltx_text ltx_font_typewriter">Fhat</span> processor is initiated. The virtual machine process (<span id="S3.SS4.p1.3.7" class="ltx_text ltx_font_typewriter">fhat</span>) is called with a pointer to an ontological model of the desired machine architecture. The machine architecture is instantiated. The instantiated <span id="S3.SS4.p1.3.8" class="ltx_text ltx_font_typewriter">Fhat</span> then instantiates a <span id="S3.SS4.p1.3.9" class="ltx_text ltx_font_typewriter">Test</span> object and calls its <span id="S3.SS4.p1.3.10" class="ltx_text ltx_font_typewriter">main</span> method. The instantiated <span id="S3.SS4.p1.3.11" class="ltx_text ltx_font_typewriter">Test</span> <span id="S3.SS4.p1.3.12" class="ltx_text ltx_font_typewriter">main</span> method is executable RDF triple-code.</p>
</div>
<div id="S3.SS4.p2" class="ltx_para">
<p id="S3.SS4.p2.1" class="ltx_p">In some instances, a Fhat RVM state may already exist in the triple-store. In such cases, the following command can be invoked to point the Fhat RVM process to the stored RVM state. In the example below, assume that <span id="S3.SS4.p2.1.1" class="ltx_text ltx_font_typewriter">urn:uuid:60ab17c2</span> is of <span id="S3.SS4.p2.1.2" class="ltx_text ltx_font_typewriter">rdf:type</span> <span id="S3.SS4.p2.1.3" class="ltx_text ltx_font_typewriter">Fhat</span>.
<span id="S3.SS4.p2.1.4" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S3.SS4.p2.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

&gt; fhat -vmi urn:uuid:60ab17c2 -t http://www.triplestore.net/sparql

</pre>
<p id="S3.SS4.p2.3" class="ltx_p">When the <span id="S3.SS4.p2.3.1" class="ltx_text ltx_font_typewriter">Fhat</span> RVM state is located, <span id="S3.SS4.p2.3.2" class="ltx_text ltx_font_typewriter">fhat</span> processes the current instruction pointed to by its <span id="S3.SS4.p2.3.3" class="ltx_text ltx_font_typewriter">programLocation</span>.</p>
</div>
<div id="S3.SS4.p3" class="ltx_para">
<p id="S3.SS4.p3.1" class="ltx_p">The following list outlines the flags for the <span id="S3.SS4.p3.1.1" class="ltx_text ltx_font_typewriter">nenofhat</span> compiler,</p>
</div>
<div id="S3.SS4.p4" class="ltx_para">
<ul id="S3.I1" class="ltx_itemize">
<li id="S3.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S3.I1.i1.p1" class="ltx_para">
<p id="S3.I1.i1.p1.2" class="ltx_p">-o : output type (ntriple <math id="S3.I1.i1.p1.1.m1.1" class="ltx_Math" alttext="|" display="inline"><semantics id="S3.I1.i1.p1.1.m1.1a"><mo fence="false" stretchy="false" id="S3.I1.i1.p1.1.m1.1.1" xref="S3.I1.i1.p1.1.m1.1.1.cmml">|</mo><annotation-xml encoding="MathML-Content" id="S3.I1.i1.p1.1.m1.1b"><ci id="S3.I1.i1.p1.1.m1.1.1.cmml" xref="S3.I1.i1.p1.1.m1.1.1">|</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.I1.i1.p1.1.m1.1c">|</annotation></semantics></math> n3 <math id="S3.I1.i1.p1.2.m2.1" class="ltx_Math" alttext="|" display="inline"><semantics id="S3.I1.i1.p1.2.m2.1a"><mo fence="false" stretchy="false" id="S3.I1.i1.p1.2.m2.1.1" xref="S3.I1.i1.p1.2.m2.1.1.cmml">|</mo><annotation-xml encoding="MathML-Content" id="S3.I1.i1.p1.2.m2.1b"><ci id="S3.I1.i1.p1.2.m2.1.1.cmml" xref="S3.I1.i1.p1.2.m2.1.1">|</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.I1.i1.p1.2.m2.1c">|</annotation></semantics></math> xml)</p>
</div>
</li>
<li id="S3.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S3.I1.i2.p1" class="ltx_para">
<p id="S3.I1.i2.p1.1" class="ltx_p">-t : triple-store interface</p>
</div>
</li>
</ul>
</div>
<div id="S3.SS4.p5" class="ltx_para">
<p id="S3.SS4.p5.1" class="ltx_p">and the <span id="S3.SS4.p5.1.1" class="ltx_text ltx_font_typewriter">fhat</span> RVM process,</p>
</div>
<div id="S3.SS4.p6" class="ltx_para">
<ul id="S3.I2" class="ltx_itemize">
<li id="S3.I2.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S3.I2.i1.p1" class="ltx_para">
<p id="S3.I2.i1.p1.1" class="ltx_p">-vmi : virtual machine instance URI</p>
</div>
</li>
<li id="S3.I2.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S3.I2.i2.p1" class="ltx_para">
<p id="S3.I2.i2.p1.1" class="ltx_p">-vmc : virtual machine class URI</p>
</div>
</li>
<li id="S3.I2.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S3.I2.i3.p1" class="ltx_para">
<p id="S3.I2.i3.p1.1" class="ltx_p">-c : start class URI</p>
</div>
</li>
<li id="S3.I2.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S3.I2.i4.p1" class="ltx_para">
<p id="S3.I2.i4.p1.1" class="ltx_p">-cm : start class no-argument method</p>
</div>
</li>
<li id="S3.I2.i5" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S3.I2.i5.p1" class="ltx_para">
<p id="S3.I2.i5.p1.1" class="ltx_p">-t : triple-store interface.</p>
</div>
</li>
</ul>
</div>
</section>
</section>
<section id="S4" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">4 </span>The Fhat Virtual Machine Architecture</h2>

<div id="S4.p1" class="ltx_para">
<p id="S4.p1.1" class="ltx_p">Fhat is an RVM that was specifically designed for RDF-based semantic network languages. Fhat is a semi-hard implementation of a computing machine. Table <a href="#S4.T5" title="Table 5 ‣ 4 The Fhat Virtual Machine Architecture ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a> presents an explanation of the various levels of virtual machine implementations. The concept of soft, semi-hard, and hard implementations are developed here and thus, are not part of the common lexicon. In the JVM, all of the “hardware” components are represented in software and the state of the machine is not saved outside the current run-time environment. For VHSIC Hardware Description Language (VHDL) machines, the hardware components are modeled at the level of logic gates (AND, OR, XOR, NOT, etc.) ( ?). In Fhat, the hardware components are modeled in RDF (the state), but component execution is modeled in software (the process).</p>
</div>
<figure id="S4.T5" class="ltx_table">
<table id="S4.T5.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="S4.T5.1.1.1" class="ltx_tr">
<th id="S4.T5.1.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_l ltx_border_r ltx_border_t"><span id="S4.T5.1.1.1.1.1" class="ltx_text" style="font-size:80%;">implementation type</span></th>
<th id="S4.T5.1.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S4.T5.1.1.1.2.1" class="ltx_text" style="font-size:80%;">requirements</span></th>
<th id="S4.T5.1.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_t"><span id="S4.T5.1.1.1.3.1" class="ltx_text" style="font-size:80%;">example</span></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="S4.T5.1.2.1" class="ltx_tr">
<td id="S4.T5.1.2.1.1" class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_tt"><span id="S4.T5.1.2.1.1.1" class="ltx_text" style="font-size:80%;">soft</span></td>
<td id="S4.T5.1.2.1.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_tt"><span id="S4.T5.1.2.1.2.1" class="ltx_text" style="font-size:80%;">hardware methods</span></td>
<td id="S4.T5.1.2.1.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_tt"><span id="S4.T5.1.2.1.3.1" class="ltx_text" style="font-size:80%;">Java Virtual Machine, r-Fhat</span></td>
</tr>
<tr id="S4.T5.1.3.2" class="ltx_tr">
<td id="S4.T5.1.3.2.1" class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t"><span id="S4.T5.1.3.2.1.1" class="ltx_text" style="font-size:80%;">semi-hard</span></td>
<td id="S4.T5.1.3.2.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S4.T5.1.3.2.2.1" class="ltx_text" style="font-size:80%;">high-level components</span></td>
<td id="S4.T5.1.3.2.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span id="S4.T5.1.3.2.3.1" class="ltx_text" style="font-size:80%;">Fhat</span></td>
</tr>
<tr id="S4.T5.1.4.3" class="ltx_tr">
<td id="S4.T5.1.4.3.1" class="ltx_td ltx_align_center ltx_border_b ltx_border_l ltx_border_r ltx_border_t"><span id="S4.T5.1.4.3.1.1" class="ltx_text" style="font-size:80%;">hard</span></td>
<td id="S4.T5.1.4.3.2" class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t"><span id="S4.T5.1.4.3.2.1" class="ltx_text" style="font-size:80%;">low-level components</span></td>
<td id="S4.T5.1.4.3.3" class="ltx_td ltx_align_center ltx_border_b ltx_border_r ltx_border_t"><span id="S4.T5.1.4.3.3.1" class="ltx_text" style="font-size:80%;">VHDL designs</span></td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption ltx_centering" style="font-size:80%;"><span class="ltx_tag ltx_tag_table">Table 5: </span> Different VM implementation types, their requirements, and an example.</figcaption>
</figure>
<div id="S4.p2" class="ltx_para">
<p id="S4.p2.1" class="ltx_p">There are many reasons why a semi-hard implementation was desired for Fhat and these reasons will be articulated in the sections discussing the various components of the Fhat architecture. However, while this section presents the semi-hard implementation, a soft implementation of Fhat called reduced Fhat (r-Fhat) will be briefly discussed. In short, r-Fhat is faster than the Fhat virtual machine, but does not support run-time machine portability and machine-level reflection. In other words, r-Fhat does not support those functions that require an RDF representation of the machine state.</p>
</div>
<div id="S4.p3" class="ltx_para">
<p id="S4.p3.1" class="ltx_p">Any high-level language can be written to take advantage of the Fhat architecture. While Neno and Fhat were developed in concert and thus, are strongly connected in their requirements of one another, any language that compiles to Fhat RDF triple-code can use a Fhat RVM. This section will discuss the Fhat RVM before discussing the Fhat instruction set. Figure <a href="#S4.F5" title="Figure 5 ‣ 4 The Fhat Virtual Machine Architecture ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a> presents the Fhat machine architecture. This machine architecture is represented in OWL and is co-located with other resources in the ontology layer of the RDF network.</p>
</div>
<figure id="S4.F5" class="ltx_figure"><img src="/html/0704.3395/assets/x5.png" id="S4.F5.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="403" height="277" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 5: </span>The ontological model of the Fhat virtual machine.</figcaption>
</figure>
<div id="S4.p4" class="ltx_para">
<p id="S4.p4.1" class="ltx_p">There are <math id="S4.p4.1.m1.1" class="ltx_Math" alttext="8" display="inline"><semantics id="S4.p4.1.m1.1a"><mn id="S4.p4.1.m1.1.1" xref="S4.p4.1.m1.1.1.cmml">8</mn><annotation-xml encoding="MathML-Content" id="S4.p4.1.m1.1b"><cn type="integer" id="S4.p4.1.m1.1.1.cmml" xref="S4.p4.1.m1.1.1">8</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.p4.1.m1.1c">8</annotation></semantics></math> primary components to the Fhat RVM. These are enumerated below for ease of reference. Each component will be discussed in more detail in the following subsections.</p>
</div>
<div id="S4.p5" class="ltx_para">
<ol id="S4.I1" class="ltx_enumerate">
<li id="S4.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">1.</span> 
<div id="S4.I1.i1.p1" class="ltx_para">
<p id="S4.I1.i1.p1.1" class="ltx_p"><span id="S4.I1.i1.p1.1.1" class="ltx_text ltx_font_typewriter">Fhat</span>: the CPU that interprets instructions and uses its various components for processing those instructions.</p>
</div>
</li>
<li id="S4.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">2.</span> 
<div id="S4.I1.i2.p1" class="ltx_para">
<p id="S4.I1.i2.p1.1" class="ltx_p"><span id="S4.I1.i2.p1.1.1" class="ltx_text ltx_font_typewriter">halt</span>: suspends Fhat processing when false, and permits processing when true.</p>
</div>
</li>
<li id="S4.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">3.</span> 
<div id="S4.I1.i3.p1" class="ltx_para">
<p id="S4.I1.i3.p1.1" class="ltx_p"><span id="S4.I1.i3.p1.1.1" class="ltx_text ltx_font_typewriter">methodReuse</span>: determines whether or not method triple-code is reused amongst object instances.</p>
</div>
</li>
<li id="S4.I1.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">4.</span> 
<div id="S4.I1.i4.p1" class="ltx_para">
<p id="S4.I1.i4.p1.1" class="ltx_p"><span id="S4.I1.i4.p1.1.1" class="ltx_text ltx_font_typewriter">programLocation</span>: a pointer to the current instruction being executed (i.e. a PC).</p>
</div>
</li>
<li id="S4.I1.i5" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">5.</span> 
<div id="S4.I1.i5.p1" class="ltx_para">
<p id="S4.I1.i5.p1.1" class="ltx_p"><span id="S4.I1.i5.p1.1.1" class="ltx_text ltx_font_typewriter">BlockStack</span>: an <span id="S4.I1.i5.p1.1.2" class="ltx_text ltx_font_typewriter">rdf:List</span> that can be pushed and popped for entering and exiting blocks.</p>
</div>
</li>
<li id="S4.I1.i6" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">6.</span> 
<div id="S4.I1.i6.p1" class="ltx_para">
<p id="S4.I1.i6.p1.1" class="ltx_p"><span id="S4.I1.i6.p1.1.1" class="ltx_text ltx_font_typewriter">OperandStack</span>: an <span id="S4.I1.i6.p1.1.2" class="ltx_text ltx_font_typewriter">rdf:List</span> that can be pushed and popped for arithmetic computations.</p>
</div>
</li>
<li id="S4.I1.i7" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">7.</span> 
<div id="S4.I1.i7.p1" class="ltx_para">
<p id="S4.I1.i7.p1.1" class="ltx_p"><span id="S4.I1.i7.p1.1.1" class="ltx_text ltx_font_typewriter">Frame</span>: a <span id="S4.I1.i7.p1.1.2" class="ltx_text ltx_font_typewriter">Method</span> unique environment for storing local variables.</p>
</div>
</li>
<li id="S4.I1.i8" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">8.</span> 
<div id="S4.I1.i8.p1" class="ltx_para">
<p id="S4.I1.i8.p1.1" class="ltx_p"><span id="S4.I1.i8.p1.1.1" class="ltx_text ltx_font_typewriter">ReturnStack</span>: an <span id="S4.I1.i8.p1.1.2" class="ltx_text ltx_font_typewriter">rdf:List</span> that provides a reference to the instruction that called a method and the frame of that method.</p>
</div>
</li>
</ol>
</div>
<div id="S4.p6" class="ltx_para">
<p id="S4.p6.1" class="ltx_p">While all of these components are represented in RDF, only <span id="S4.p6.1.1" class="ltx_text ltx_font_typewriter">Fhat</span> has an external software component. The software implementation of <span id="S4.p6.1.2" class="ltx_text ltx_font_typewriter">Fhat</span> is called the “virtual machine process” in Figure <a href="#S2.F3" title="Figure 3 ‣ 2 A High-Level Perspective ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>.<span id="footnote13" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">13</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">13</sup><span class="ltx_tag ltx_tag_note">13</span>When the term Fhat is used, it is referring to the entire virtual machine, when the teletyped term <span id="footnote13.1" class="ltx_text ltx_font_typewriter">Fhat</span> is used, it is referring to the virtual machine process identified by the URI <span id="footnote13.2" class="ltx_text ltx_font_typewriter">Fhat</span>.</span></span></span></p>
</div>
<section id="S4.SS0.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.0.1 </span><span id="S4.SS0.SSS1.1.1" class="ltx_text ltx_font_typewriter">Fhat</span>
</h4>

<div id="S4.SS0.SSS1.p1" class="ltx_para">
<p id="S4.SS0.SSS1.p1.1" class="ltx_p"><span id="S4.SS0.SSS1.p1.1.1" class="ltx_text ltx_font_typewriter">Fhat</span> is the primary component of the Fhat RVM. <span id="S4.SS0.SSS1.p1.1.2" class="ltx_text ltx_font_typewriter">Fhat</span> is the most complicated component in the entire Fhat architecture. The high-level Neno pseudo-code for the <span id="S4.SS0.SSS1.p1.1.3" class="ltx_text ltx_font_typewriter">Fhat</span> component is
<span id="S4.SS0.SSS1.p1.1.4" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S4.SS0.SSS1.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

Thing Fhat {
  execute() {
    while(!this.halt &amp;&amp; this.programLocation != null) {
      Instruction i = this.programLocation
      if(i typeof Block) { ... }
      else if(i typeof If) { ... }
      else if(i typeof Expression) { ... }
      else if(i typeof Set) { ... }
      ...
      /* update programLocation */
    }
  }
}

</pre>
<p id="S4.SS0.SSS1.p1.3" class="ltx_p">The above pseudo-code should be implemented in the language of the virtual machine process and thus, for the executing hardware CPU.</p>
</div>
<div id="S4.SS0.SSS1.p2" class="ltx_para">
<p id="S4.SS0.SSS1.p2.1" class="ltx_p">It is worth noting that a <span id="S4.SS0.SSS1.p2.1.1" class="ltx_text ltx_font_typewriter">Fhat</span> virtual machine process can be written in Neno as demonstrated in the Neno code above. For example, assume a Neno implemented Fhat instance called Fhat1. In such cases, another Fhat, called Fhat2, is processing Fhat1. Fhat2 can be run on yet another Fhat, called Fhat3, or grounded into some other language that is translating code to the native machine language. This is possible because Neno/Fhat is Turing complete and thus, can run a simulation of itself. When a simulation of itself is run, a complete RDF virtual machine is created. In this simulation environment, both the state and process of the Fhat RVM are represented in RDF.</p>
</div>
<div id="S4.SS0.SSS1.p3" class="ltx_para">
<p id="S4.SS0.SSS1.p3.1" class="ltx_p">The current version of Fhat supports most common uses of the <span id="S4.SS0.SSS1.p3.1.1" class="ltx_text ltx_font_typewriter">xsd:anySimpleType</span> and a few of these uses are summarized below:</p>
</div>
<div id="S4.SS0.SSS1.p4" class="ltx_para">
<ul id="S4.I2" class="ltx_itemize">
<li id="S4.I2.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S4.I2.i1.p1" class="ltx_para">
<p id="S4.I2.i1.p1.1" class="ltx_p"><span id="S4.I2.i1.p1.1.1" class="ltx_text ltx_font_typewriter">xsd:boolean</span>: <span id="S4.I2.i1.p1.1.2" class="ltx_text ltx_font_typewriter">Not</span>, <span id="S4.I2.i1.p1.1.3" class="ltx_text ltx_font_typewriter">Equals</span></p>
</div>
</li>
<li id="S4.I2.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S4.I2.i2.p1" class="ltx_para">
<p id="S4.I2.i2.p1.1" class="ltx_p"><span id="S4.I2.i2.p1.1.1" class="ltx_text ltx_font_typewriter">xsd:integer</span>, <span id="S4.I2.i2.p1.1.2" class="ltx_text ltx_font_typewriter">xsd:float</span>, <span id="S4.I2.i2.p1.1.3" class="ltx_text ltx_font_typewriter">xsd:double</span>: <span id="S4.I2.i2.p1.1.4" class="ltx_text ltx_font_typewriter">Arithmetic</span>, <span id="S4.I2.i2.p1.1.5" class="ltx_text ltx_font_typewriter">Compare</span></p>
</div>
</li>
<li id="S4.I2.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S4.I2.i3.p1" class="ltx_para">
<p id="S4.I2.i3.p1.1" class="ltx_p"><span id="S4.I2.i3.p1.1.1" class="ltx_text ltx_font_typewriter">xsd:string</span>: <span id="S4.I2.i3.p1.1.2" class="ltx_text ltx_font_typewriter">Add</span>, <span id="S4.I2.i3.p1.1.3" class="ltx_text ltx_font_typewriter">Compare</span></p>
</div>
</li>
<li id="S4.I2.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S4.I2.i4.p1" class="ltx_para">
<p id="S4.I2.i4.p1.1" class="ltx_p"><span id="S4.I2.i4.p1.1.1" class="ltx_text ltx_font_typewriter">xsd:date</span>, <span id="S4.I2.i4.p1.1.2" class="ltx_text ltx_font_typewriter">xsd:dateTime</span>: <span id="S4.I2.i4.p1.1.3" class="ltx_text ltx_font_typewriter">Add</span>, <span id="S4.I2.i4.p1.1.4" class="ltx_text ltx_font_typewriter">Subtract</span>, <span id="S4.I2.i4.p1.1.5" class="ltx_text ltx_font_typewriter">Compare</span></p>
</div>
</li>
<li id="S4.I2.i5" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S4.I2.i5.p1" class="ltx_para">
<p id="S4.I2.i5.p1.1" class="ltx_p"><span id="S4.I2.i5.p1.1.1" class="ltx_text ltx_font_typewriter">xsd:anyURI</span>: <span id="S4.I2.i5.p1.1.2" class="ltx_text ltx_font_typewriter">Compare</span>.</p>
</div>
</li>
</ul>
</div>
</section>
<section id="S4.SS0.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.0.2 </span><span id="S4.SS0.SSS2.1.1" class="ltx_text ltx_font_typewriter">halt</span>
</h4>

<div id="S4.SS0.SSS2.p1" class="ltx_para">
<p id="S4.SS0.SSS2.p1.2" class="ltx_p">At any time, <span id="S4.SS0.SSS2.p1.2.3" class="ltx_text ltx_font_typewriter">Fhat</span> can be forced to halt by setting the <span id="S4.SS0.SSS2.p1.2.4" class="ltx_text ltx_font_typewriter">halt</span> property of <span id="S4.SS0.SSS2.p1.2.5" class="ltx_text ltx_font_typewriter">Fhat</span> to <span id="S4.SS0.SSS2.p1.2.2" class="ltx_text ltx_font_typewriter">true<sup id="S4.SS0.SSS2.p1.2.2.1" class="ltx_sup"><span id="S4.SS0.SSS2.p1.2.2.1.1" class="ltx_text ltx_font_serif">∧</span></sup><sup id="S4.SS0.SSS2.p1.2.2.2" class="ltx_sup"><span id="S4.SS0.SSS2.p1.2.2.2.1" class="ltx_text ltx_font_serif">∧</span></sup>xsd:boolean</span>. Multi-threading can be simulated in this way. A Neno program can be engineered to run a master <span id="S4.SS0.SSS2.p1.2.6" class="ltx_text ltx_font_typewriter">Fhat</span> that has a reference to the <span id="S4.SS0.SSS2.p1.2.7" class="ltx_text ltx_font_typewriter">halt</span> property of all its slave <span id="S4.SS0.SSS2.p1.2.8" class="ltx_text ltx_font_typewriter">Fhat</span>s. By setting the <span id="S4.SS0.SSS2.p1.2.9" class="ltx_text ltx_font_typewriter">halt</span> property, the <span id="S4.SS0.SSS2.p1.2.10" class="ltx_text ltx_font_typewriter">Fhat</span> master can control which <span id="S4.SS0.SSS2.p1.2.11" class="ltx_text ltx_font_typewriter">Fhat</span> slaves are able to process at any one time. In essence, the master <span id="S4.SS0.SSS2.p1.2.12" class="ltx_text ltx_font_typewriter">Fhat</span> serves as an operating system.</p>
</div>
</section>
<section id="S4.SS0.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.0.3 </span><span id="S4.SS0.SSS3.1.1" class="ltx_text ltx_font_typewriter">methodReuse</span>
</h4>

<div id="S4.SS0.SSS3.p1" class="ltx_para">
<p id="S4.SS0.SSS3.p1.4" class="ltx_p">When <span id="S4.SS0.SSS3.p1.4.5" class="ltx_text ltx_font_typewriter">methodReuse</span> is set to <span id="S4.SS0.SSS3.p1.2.2" class="ltx_text ltx_font_typewriter">true<sup id="S4.SS0.SSS3.p1.2.2.1" class="ltx_sup"><span id="S4.SS0.SSS3.p1.2.2.1.1" class="ltx_text ltx_font_serif">∧</span></sup><sup id="S4.SS0.SSS3.p1.2.2.2" class="ltx_sup"><span id="S4.SS0.SSS3.p1.2.2.2.1" class="ltx_text ltx_font_serif">∧</span></sup>xsd:boolean</span>, <span id="S4.SS0.SSS3.p1.4.6" class="ltx_text ltx_font_typewriter">Fhat</span> will instantiate new objects with unique instructions for each method. When <span id="S4.SS0.SSS3.p1.4.7" class="ltx_text ltx_font_typewriter">methodReuse</span> is set to <span id="S4.SS0.SSS3.p1.4.4" class="ltx_text ltx_font_typewriter">false<sup id="S4.SS0.SSS3.p1.4.4.1" class="ltx_sup"><span id="S4.SS0.SSS3.p1.4.4.1.1" class="ltx_text ltx_font_serif">∧</span></sup><sup id="S4.SS0.SSS3.p1.4.4.2" class="ltx_sup"><span id="S4.SS0.SSS3.p1.4.4.2.1" class="ltx_text ltx_font_serif">∧</span></sup>xsd:boolean</span>, <span id="S4.SS0.SSS3.p1.4.8" class="ltx_text ltx_font_typewriter">Fhat</span> will reuse method triple-code amongst the same methods for the different objects. This will be discussed in more detail in §<a href="#S5.SS2" title="5.2 A Method Instance ‣ 5 The Fhat Instruction Set ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">5.2</span></a>.</p>
</div>
</section>
<section id="S4.SS0.SSS4" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.0.4 </span><span id="S4.SS0.SSS4.1.1" class="ltx_text ltx_font_typewriter">programLocation</span>
</h4>

<div id="S4.SS0.SSS4.p1" class="ltx_para">
<p id="S4.SS0.SSS4.p1.1" class="ltx_p">The <span id="S4.SS0.SSS4.p1.1.1" class="ltx_text ltx_font_typewriter">programLocation</span> is a pointer to the current instruction being executed by Fhat. Fhat executes one instruction at a time and thus, the <span id="S4.SS0.SSS4.p1.1.2" class="ltx_text ltx_font_typewriter">programLocation</span> must always point to a single instruction. The “while” loop of Fhat simply moves the <span id="S4.SS0.SSS4.p1.1.3" class="ltx_text ltx_font_typewriter">programLocation</span> from one instruction to the next. At each instruction, Fhat interprets what the instruction is (by its <span id="S4.SS0.SSS4.p1.1.4" class="ltx_text ltx_font_typewriter">rdf:type</span> “opcode”) and uses its various components appropriately. When there are no more instructions (i.e. when there no longer exists a <span id="S4.SS0.SSS4.p1.1.5" class="ltx_text ltx_font_typewriter">programLocation</span> property), Fhat halts.</p>
</div>
</section>
<section id="S4.SS0.SSS5" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.0.5 </span><span id="S4.SS0.SSS5.1.1" class="ltx_text ltx_font_typewriter">BlockStack</span>
</h4>

<div id="S4.SS0.SSS5.p1" class="ltx_para">
<p id="S4.SS0.SSS5.p1.1" class="ltx_p">The <span id="S4.SS0.SSS5.p1.1.1" class="ltx_text ltx_font_typewriter">BlockStack</span> is important for variable setting. When a new variable is created in a block of code, it is necessary to associate that variable with that block. When the thread of execution exits the block, all variables created in that block are dereferenced (i.e. deallocated).</p>
</div>
</section>
<section id="S4.SS0.SSS6" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.0.6 </span><span id="S4.SS0.SSS6.1.1" class="ltx_text ltx_font_typewriter">OperandStack</span>
</h4>

<div id="S4.SS0.SSS6.p1" class="ltx_para">
<p id="S4.SS0.SSS6.p1.1" class="ltx_p">The <span id="S4.SS0.SSS6.p1.1.1" class="ltx_text ltx_font_typewriter">OperandStack</span> is a LIFO (i.e. “last in, first out”) stack that supports any <span id="S4.SS0.SSS6.p1.1.2" class="ltx_text ltx_font_typewriter">rdfs:Resource</span>. The <span id="S4.SS0.SSS6.p1.1.3" class="ltx_text ltx_font_typewriter">OperandStack</span> is used for local computations such as <span id="S4.SS0.SSS6.p1.1.4" class="ltx_text ltx_font_typewriter">x = 1 + (2 * 3)</span>. For example, when <span id="S4.SS0.SSS6.p1.1.5" class="ltx_text ltx_font_typewriter">x = 1 + (2 * 3)</span> is executed by <span id="S4.SS0.SSS6.p1.1.6" class="ltx_text ltx_font_typewriter">Fhat</span>, <span id="S4.SS0.SSS6.p1.1.7" class="ltx_text ltx_font_typewriter">Fhat</span> will</p>
</div>
<div id="S4.SS0.SSS6.p2" class="ltx_para">
<ol id="S4.I3" class="ltx_enumerate">
<li id="S4.I3.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">1.</span> 
<div id="S4.I3.i1.p1" class="ltx_para">
<p id="S4.I3.i1.p1.1" class="ltx_p">push the value 1 on the <span id="S4.I3.i1.p1.1.1" class="ltx_text ltx_font_typewriter">OperandStack</span></p>
</div>
</li>
<li id="S4.I3.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">2.</span> 
<div id="S4.I3.i2.p1" class="ltx_para">
<p id="S4.I3.i2.p1.1" class="ltx_p">push the value 2 on the <span id="S4.I3.i2.p1.1.1" class="ltx_text ltx_font_typewriter">OperandStack</span></p>
</div>
</li>
<li id="S4.I3.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">3.</span> 
<div id="S4.I3.i3.p1" class="ltx_para">
<p id="S4.I3.i3.p1.1" class="ltx_p">push the value 3 on the <span id="S4.I3.i3.p1.1.1" class="ltx_text ltx_font_typewriter">OperandStack</span></p>
</div>
</li>
<li id="S4.I3.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">4.</span> 
<div id="S4.I3.i4.p1" class="ltx_para">
<p id="S4.I3.i4.p1.1" class="ltx_p">pop both 2 and 3 off the <span id="S4.I3.i4.p1.1.1" class="ltx_text ltx_font_typewriter">OperandStack</span>, multiply the two operands, and push the value 6 on the <span id="S4.I3.i4.p1.1.2" class="ltx_text ltx_font_typewriter">OperandStack</span></p>
</div>
</li>
<li id="S4.I3.i5" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">5.</span> 
<div id="S4.I3.i5.p1" class="ltx_para">
<p id="S4.I3.i5.p1.1" class="ltx_p">pop both 1 and 6 the <span id="S4.I3.i5.p1.1.1" class="ltx_text ltx_font_typewriter">OperandStack</span>, add the two operands, and push the value 7 on the <span id="S4.I3.i5.p1.1.2" class="ltx_text ltx_font_typewriter">OperandStack</span></p>
</div>
</li>
<li id="S4.I3.i6" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">6.</span> 
<div id="S4.I3.i6.p1" class="ltx_para">
<p id="S4.I3.i6.p1.1" class="ltx_p">set the current <span id="S4.I3.i6.p1.1.1" class="ltx_text ltx_font_typewriter">Frame</span> <span id="S4.I3.i6.p1.1.2" class="ltx_text ltx_font_typewriter">FrameVariable</span> <span id="S4.I3.i6.p1.1.3" class="ltx_text ltx_font_typewriter">x</span> to the value <math id="S4.I3.i6.p1.1.m1.1" class="ltx_Math" alttext="7" display="inline"><semantics id="S4.I3.i6.p1.1.m1.1a"><mn id="S4.I3.i6.p1.1.m1.1.1" xref="S4.I3.i6.p1.1.m1.1.1.cmml">7</mn><annotation-xml encoding="MathML-Content" id="S4.I3.i6.p1.1.m1.1b"><cn type="integer" id="S4.I3.i6.p1.1.m1.1.1.cmml" xref="S4.I3.i6.p1.1.m1.1.1">7</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.I3.i6.p1.1.m1.1c">7</annotation></semantics></math> popped off the <span id="S4.I3.i6.p1.1.4" class="ltx_text ltx_font_typewriter">OperandStack</span>.</p>
</div>
</li>
</ol>
</div>
<div id="S4.SS0.SSS6.p3" class="ltx_para">
<p id="S4.SS0.SSS6.p3.1" class="ltx_p">The Neno statement <span id="S4.SS0.SSS6.p3.1.1" class="ltx_text ltx_font_typewriter">x = 1 + (2 * 3)</span> is actually multiple instructions when compiled to Fhat triple-code. The NenoFhat compiler would translate the statement to the triple-code represented in Figure <a href="#S4.F6" title="Figure 6 ‣ 4.0.6 OperandStack ‣ 4 The Fhat Virtual Machine Architecture ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>.</p>
</div>
<figure id="S4.F6" class="ltx_figure"><img src="" id="S4.F6.g1" class="ltx_graphics ltx_centering ltx_missing ltx_missing_image" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 6: </span>The triple-code representation of the statement <span id="S4.F6.2.1" class="ltx_text ltx_font_typewriter">x = 1 + (2 * 3)</span>.</figcaption>
</figure>
<div id="S4.SS0.SSS6.p4" class="ltx_para">
<p id="S4.SS0.SSS6.p4.1" class="ltx_p">It is very important to represent such components as the <span id="S4.SS0.SSS6.p4.1.1" class="ltx_text ltx_font_typewriter">OperandStack</span> component in RDF and not simply in the memory of the host CPU. Suppose that a Fhat instance is to move to another physical machine or, by chance, lose its process “back-end”. If any of these two scenarios were the case, the state of the machine is always saved in RDF and thus, would simply “freeze” to await another virtual machine process to continue its execution. If the <span id="S4.SS0.SSS6.p4.1.2" class="ltx_text ltx_font_typewriter">OperandStack</span> was represented in software and thus, in RAM, then when the software halted, the <span id="S4.SS0.SSS6.p4.1.3" class="ltx_text ltx_font_typewriter">OperandStack</span> would be lost and the state of the machine would be inconsistent with its <span id="S4.SS0.SSS6.p4.1.4" class="ltx_text ltx_font_typewriter">programLocation</span>. With an RDF state, the RAM representation of the virtual machine process has a negligible effect on the consistency of the machine.</p>
</div>
</section>
<section id="S4.SS0.SSS7" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.0.7 </span><span id="S4.SS0.SSS7.1.1" class="ltx_text ltx_font_typewriter">Frame</span>
</h4>

<div id="S4.SS0.SSS7.p1" class="ltx_para">
<p id="S4.SS0.SSS7.p1.4" class="ltx_p">Fhat is a frame-based processor. This means that each invoked method is provided a <span id="S4.SS0.SSS7.p1.4.1" class="ltx_text ltx_font_typewriter">Frame</span>, or local environment, for its variables (i.e. <span id="S4.SS0.SSS7.p1.4.2" class="ltx_text ltx_font_typewriter">FrameVariable</span>s). Due to how variables are scoped in object-oriented languages and because Neno does not support global variables, each method can only communicate with one another through parameter (i.e. method arguments) passing, return value passing, or object manipulations. When method <math id="S4.SS0.SSS7.p1.1.m1.1" class="ltx_Math" alttext="A" display="inline"><semantics id="S4.SS0.SSS7.p1.1.m1.1a"><mi id="S4.SS0.SSS7.p1.1.m1.1.1" xref="S4.SS0.SSS7.p1.1.m1.1.1.cmml">A</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.1.m1.1b"><ci id="S4.SS0.SSS7.p1.1.m1.1.1.cmml" xref="S4.SS0.SSS7.p1.1.m1.1.1">𝐴</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.1.m1.1c">A</annotation></semantics></math> calls method <math id="S4.SS0.SSS7.p1.2.m2.1" class="ltx_Math" alttext="B" display="inline"><semantics id="S4.SS0.SSS7.p1.2.m2.1a"><mi id="S4.SS0.SSS7.p1.2.m2.1.1" xref="S4.SS0.SSS7.p1.2.m2.1.1.cmml">B</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.2.m2.1b"><ci id="S4.SS0.SSS7.p1.2.m2.1.1.cmml" xref="S4.SS0.SSS7.p1.2.m2.1.1">𝐵</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.2.m2.1c">B</annotation></semantics></math>, the parameters passed by method <math id="S4.SS0.SSS7.p1.3.m3.1" class="ltx_Math" alttext="A" display="inline"><semantics id="S4.SS0.SSS7.p1.3.m3.1a"><mi id="S4.SS0.SSS7.p1.3.m3.1.1" xref="S4.SS0.SSS7.p1.3.m3.1.1.cmml">A</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.3.m3.1b"><ci id="S4.SS0.SSS7.p1.3.m3.1.1.cmml" xref="S4.SS0.SSS7.p1.3.m3.1.1">𝐴</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.3.m3.1c">A</annotation></semantics></math> are stored in method <math id="S4.SS0.SSS7.p1.4.m4.1" class="ltx_Math" alttext="B" display="inline"><semantics id="S4.SS0.SSS7.p1.4.m4.1a"><mi id="S4.SS0.SSS7.p1.4.m4.1.1" xref="S4.SS0.SSS7.p1.4.m4.1.1.cmml">B</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.4.m4.1b"><ci id="S4.SS0.SSS7.p1.4.m4.1.1.cmml" xref="S4.SS0.SSS7.p1.4.m4.1.1">𝐵</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.4.m4.1c">B</annotation></semantics></math>’s <span id="S4.SS0.SSS7.p1.4.3" class="ltx_text ltx_font_typewriter">Frame</span> according to the variable names in the method description. For example, assume the following method,
<span id="S4.SS0.SSS7.p1.4.4" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S4.SS0.SSS7.p1.14" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

xsd:integer methodB(xsd:integer a) {
  return a + "1"^^xsd:integer;
}

</pre>
<p id="S4.SS0.SSS7.p1.6" class="ltx_p">If method <math id="S4.SS0.SSS7.p1.5.m1.1" class="ltx_Math" alttext="A" display="inline"><semantics id="S4.SS0.SSS7.p1.5.m1.1a"><mi id="S4.SS0.SSS7.p1.5.m1.1.1" xref="S4.SS0.SSS7.p1.5.m1.1.1.cmml">A</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.5.m1.1b"><ci id="S4.SS0.SSS7.p1.5.m1.1.1.cmml" xref="S4.SS0.SSS7.p1.5.m1.1.1">𝐴</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.5.m1.1c">A</annotation></semantics></math> calls method <math id="S4.SS0.SSS7.p1.6.m2.1" class="ltx_Math" alttext="B" display="inline"><semantics id="S4.SS0.SSS7.p1.6.m2.1a"><mi id="S4.SS0.SSS7.p1.6.m2.1.1" xref="S4.SS0.SSS7.p1.6.m2.1.1.cmml">B</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.6.m2.1b"><ci id="S4.SS0.SSS7.p1.6.m2.1.1.cmml" xref="S4.SS0.SSS7.p1.6.m2.1.1">𝐵</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.6.m2.1c">B</annotation></semantics></math>, with the statement,
<span id="S4.SS0.SSS7.p1.6.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S4.SS0.SSS7.p1.15" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

xsd:integer x = marko.methodB("2"^^xsd:integer);

</pre>
<p id="S4.SS0.SSS7.p1.13" class="ltx_p">the value <math id="S4.SS0.SSS7.p1.7.m1.1" class="ltx_Math" alttext="2" display="inline"><semantics id="S4.SS0.SSS7.p1.7.m1.1a"><mn id="S4.SS0.SSS7.p1.7.m1.1.1" xref="S4.SS0.SSS7.p1.7.m1.1.1.cmml">2</mn><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.7.m1.1b"><cn type="integer" id="S4.SS0.SSS7.p1.7.m1.1.1.cmml" xref="S4.SS0.SSS7.p1.7.m1.1.1">2</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.7.m1.1c">2</annotation></semantics></math> is placed into the <span id="S4.SS0.SSS7.p1.13.1" class="ltx_text ltx_font_typewriter">Frame</span> of method <math id="S4.SS0.SSS7.p1.8.m2.1" class="ltx_Math" alttext="B" display="inline"><semantics id="S4.SS0.SSS7.p1.8.m2.1a"><mi id="S4.SS0.SSS7.p1.8.m2.1.1" xref="S4.SS0.SSS7.p1.8.m2.1.1.cmml">B</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.8.m2.1b"><ci id="S4.SS0.SSS7.p1.8.m2.1.1.cmml" xref="S4.SS0.SSS7.p1.8.m2.1.1">𝐵</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.8.m2.1c">B</annotation></semantics></math> with the associated variable <span id="S4.SS0.SSS7.p1.13.2" class="ltx_text ltx_font_typewriter">a</span>. Method <math id="S4.SS0.SSS7.p1.9.m3.1" class="ltx_Math" alttext="B" display="inline"><semantics id="S4.SS0.SSS7.p1.9.m3.1a"><mi id="S4.SS0.SSS7.p1.9.m3.1.1" xref="S4.SS0.SSS7.p1.9.m3.1.1.cmml">B</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.9.m3.1b"><ci id="S4.SS0.SSS7.p1.9.m3.1.1.cmml" xref="S4.SS0.SSS7.p1.9.m3.1.1">𝐵</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.9.m3.1c">B</annotation></semantics></math> adds <math id="S4.SS0.SSS7.p1.10.m4.1" class="ltx_Math" alttext="1" display="inline"><semantics id="S4.SS0.SSS7.p1.10.m4.1a"><mn id="S4.SS0.SSS7.p1.10.m4.1.1" xref="S4.SS0.SSS7.p1.10.m4.1.1.cmml">1</mn><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.10.m4.1b"><cn type="integer" id="S4.SS0.SSS7.p1.10.m4.1.1.cmml" xref="S4.SS0.SSS7.p1.10.m4.1.1">1</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.10.m4.1c">1</annotation></semantics></math> to the value and pushes the value <math id="S4.SS0.SSS7.p1.11.m5.1" class="ltx_Math" alttext="3" display="inline"><semantics id="S4.SS0.SSS7.p1.11.m5.1a"><mn id="S4.SS0.SSS7.p1.11.m5.1.1" xref="S4.SS0.SSS7.p1.11.m5.1.1.cmml">3</mn><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.11.m5.1b"><cn type="integer" id="S4.SS0.SSS7.p1.11.m5.1.1.cmml" xref="S4.SS0.SSS7.p1.11.m5.1.1">3</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.11.m5.1c">3</annotation></semantics></math> on the <span id="S4.SS0.SSS7.p1.13.3" class="ltx_text ltx_font_typewriter">OperandStack</span>. Method <math id="S4.SS0.SSS7.p1.12.m6.1" class="ltx_Math" alttext="A" display="inline"><semantics id="S4.SS0.SSS7.p1.12.m6.1a"><mi id="S4.SS0.SSS7.p1.12.m6.1.1" xref="S4.SS0.SSS7.p1.12.m6.1.1.cmml">A</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.12.m6.1b"><ci id="S4.SS0.SSS7.p1.12.m6.1.1.cmml" xref="S4.SS0.SSS7.p1.12.m6.1.1">𝐴</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.12.m6.1c">A</annotation></semantics></math> pops one value off the <span id="S4.SS0.SSS7.p1.13.4" class="ltx_text ltx_font_typewriter">OperandStack</span> and sets the local variable <span id="S4.SS0.SSS7.p1.13.5" class="ltx_text ltx_font_typewriter">x</span> to the value <math id="S4.SS0.SSS7.p1.13.m7.1" class="ltx_Math" alttext="3" display="inline"><semantics id="S4.SS0.SSS7.p1.13.m7.1a"><mn id="S4.SS0.SSS7.p1.13.m7.1.1" xref="S4.SS0.SSS7.p1.13.m7.1.1.cmml">3</mn><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS7.p1.13.m7.1b"><cn type="integer" id="S4.SS0.SSS7.p1.13.m7.1.1.cmml" xref="S4.SS0.SSS7.p1.13.m7.1.1">3</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS7.p1.13.m7.1c">3</annotation></semantics></math>. The <span id="S4.SS0.SSS7.p1.13.6" class="ltx_text ltx_font_typewriter">OperandStack</span> is used for the placement of method return values.</p>
</div>
</section>
<section id="S4.SS0.SSS8" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">4.0.8 </span><span id="S4.SS0.SSS8.1.1" class="ltx_text ltx_font_typewriter">ReturnStack</span>
</h4>

<div id="S4.SS0.SSS8.p1" class="ltx_para">
<p id="S4.SS0.SSS8.p1.1" class="ltx_p">The <span id="S4.SS0.SSS8.p1.1.1" class="ltx_text ltx_font_typewriter">ReturnStack</span> is a LIFO stack that maintains pointers to the return location of a method and the method <span id="S4.SS0.SSS8.p1.1.2" class="ltx_text ltx_font_typewriter">Frame</span>. To support recursion, the <span id="S4.SS0.SSS8.p1.1.3" class="ltx_text ltx_font_typewriter">ReturnStack</span> maintains a pointer to the specific <span id="S4.SS0.SSS8.p1.1.4" class="ltx_text ltx_font_typewriter">Frame</span> that is being returned to.</p>
</div>
<div id="S4.SS0.SSS8.p2" class="ltx_para">
<p id="S4.SS0.SSS8.p2.8" class="ltx_p">In order to explain how the <span id="S4.SS0.SSS8.p2.8.1" class="ltx_text ltx_font_typewriter">ReturnStack</span> is used, an example is provided. When method <math id="S4.SS0.SSS8.p2.1.m1.1" class="ltx_Math" alttext="A" display="inline"><semantics id="S4.SS0.SSS8.p2.1.m1.1a"><mi id="S4.SS0.SSS8.p2.1.m1.1.1" xref="S4.SS0.SSS8.p2.1.m1.1.1.cmml">A</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS8.p2.1.m1.1b"><ci id="S4.SS0.SSS8.p2.1.m1.1.1.cmml" xref="S4.SS0.SSS8.p2.1.m1.1.1">𝐴</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS8.p2.1.m1.1c">A</annotation></semantics></math> calls method <math id="S4.SS0.SSS8.p2.2.m2.1" class="ltx_Math" alttext="B" display="inline"><semantics id="S4.SS0.SSS8.p2.2.m2.1a"><mi id="S4.SS0.SSS8.p2.2.m2.1.1" xref="S4.SS0.SSS8.p2.2.m2.1.1.cmml">B</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS8.p2.2.m2.1b"><ci id="S4.SS0.SSS8.p2.2.m2.1.1.cmml" xref="S4.SS0.SSS8.p2.2.m2.1.1">𝐵</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS8.p2.2.m2.1c">B</annotation></semantics></math>, the next instruction of method <math id="S4.SS0.SSS8.p2.3.m3.1" class="ltx_Math" alttext="A" display="inline"><semantics id="S4.SS0.SSS8.p2.3.m3.1a"><mi id="S4.SS0.SSS8.p2.3.m3.1.1" xref="S4.SS0.SSS8.p2.3.m3.1.1.cmml">A</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS8.p2.3.m3.1b"><ci id="S4.SS0.SSS8.p2.3.m3.1.1.cmml" xref="S4.SS0.SSS8.p2.3.m3.1.1">𝐴</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS8.p2.3.m3.1c">A</annotation></semantics></math> following the method invocation instruction is pushed onto the <span id="S4.SS0.SSS8.p2.8.2" class="ltx_text ltx_font_typewriter">ReturnStack</span>. When method <math id="S4.SS0.SSS8.p2.4.m4.1" class="ltx_Math" alttext="B" display="inline"><semantics id="S4.SS0.SSS8.p2.4.m4.1a"><mi id="S4.SS0.SSS8.p2.4.m4.1.1" xref="S4.SS0.SSS8.p2.4.m4.1.1.cmml">B</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS8.p2.4.m4.1b"><ci id="S4.SS0.SSS8.p2.4.m4.1.1.cmml" xref="S4.SS0.SSS8.p2.4.m4.1.1">𝐵</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS8.p2.4.m4.1c">B</annotation></semantics></math> has completed its execution (e.g. a <span id="S4.SS0.SSS8.p2.8.3" class="ltx_text ltx_font_typewriter">return</span> is called), Fhat pops the instruction off the <span id="S4.SS0.SSS8.p2.8.4" class="ltx_text ltx_font_typewriter">ReturnStack</span> and sets its <span id="S4.SS0.SSS8.p2.8.5" class="ltx_text ltx_font_typewriter">programLocation</span> to that instruction. In this way, control is returned to method <math id="S4.SS0.SSS8.p2.5.m5.1" class="ltx_Math" alttext="A" display="inline"><semantics id="S4.SS0.SSS8.p2.5.m5.1a"><mi id="S4.SS0.SSS8.p2.5.m5.1.1" xref="S4.SS0.SSS8.p2.5.m5.1.1.cmml">A</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS8.p2.5.m5.1b"><ci id="S4.SS0.SSS8.p2.5.m5.1.1.cmml" xref="S4.SS0.SSS8.p2.5.m5.1.1">𝐴</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS8.p2.5.m5.1c">A</annotation></semantics></math> to complete its execution. When <span id="S4.SS0.SSS8.p2.8.6" class="ltx_text ltx_font_typewriter">return</span> is called in method <math id="S4.SS0.SSS8.p2.6.m6.1" class="ltx_Math" alttext="B" display="inline"><semantics id="S4.SS0.SSS8.p2.6.m6.1a"><mi id="S4.SS0.SSS8.p2.6.m6.1.1" xref="S4.SS0.SSS8.p2.6.m6.1.1.cmml">B</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS8.p2.6.m6.1b"><ci id="S4.SS0.SSS8.p2.6.m6.1.1.cmml" xref="S4.SS0.SSS8.p2.6.m6.1.1">𝐵</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS8.p2.6.m6.1c">B</annotation></semantics></math>, Fhat will delete (i.e. deallocate) all triples associated with the method <math id="S4.SS0.SSS8.p2.7.m7.1" class="ltx_Math" alttext="B" display="inline"><semantics id="S4.SS0.SSS8.p2.7.m7.1a"><mi id="S4.SS0.SSS8.p2.7.m7.1.1" xref="S4.SS0.SSS8.p2.7.m7.1.1.cmml">B</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS8.p2.7.m7.1b"><ci id="S4.SS0.SSS8.p2.7.m7.1.1.cmml" xref="S4.SS0.SSS8.p2.7.m7.1.1">𝐵</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS8.p2.7.m7.1c">B</annotation></semantics></math> <span id="S4.SS0.SSS8.p2.8.7" class="ltx_text ltx_font_typewriter">Frame</span>. If <span id="S4.SS0.SSS8.p2.8.8" class="ltx_text ltx_font_typewriter">return</span> has a value (e.g. <span id="S4.SS0.SSS8.p2.8.9" class="ltx_text ltx_font_typewriter">return 2</span>), that value is pushed onto the <span id="S4.SS0.SSS8.p2.8.10" class="ltx_text ltx_font_typewriter">OperandStack</span> for method <math id="S4.SS0.SSS8.p2.8.m8.1" class="ltx_Math" alttext="A" display="inline"><semantics id="S4.SS0.SSS8.p2.8.m8.1a"><mi id="S4.SS0.SSS8.p2.8.m8.1.1" xref="S4.SS0.SSS8.p2.8.m8.1.1.cmml">A</mi><annotation-xml encoding="MathML-Content" id="S4.SS0.SSS8.p2.8.m8.1b"><ci id="S4.SS0.SSS8.p2.8.m8.1.1.cmml" xref="S4.SS0.SSS8.p2.8.m8.1.1">𝐴</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS0.SSS8.p2.8.m8.1c">A</annotation></semantics></math> to use in its computation.</p>
</div>
</section>
<section id="S4.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.1 </span>Migrating Fhat Across Different Host CPUs</h3>

<div id="S4.SS1.p1" class="ltx_para">
<p id="S4.SS1.p1.1" class="ltx_p">An interesting aspect of Fhat is the ability to migrate a Fhat process across various host CPUs. A Fhat implementation has two primary components: an RDF state representation and a software process. Because both the RDF triple-code and the complete state of a Fhat instance is represented in the RDF network, it does not matter which Fhat process is executing a particular Fhat state. The Fhat RDF state representation ensures that there are no global variables in the software process. The only variables created in the software process are local to the instruction being executed. Because there are no global variables in the software process, any software process can execute the Fhat RDF state without requiring inter-software process communication. For example, one host CPU can be running the Fhat software process and halt. Another CPU can then start another Fhat software process that points to the URI of the originally halted Fhat RDF state and continue its execution. This concept is diagrammed in Figure <a href="#S4.F7" title="Figure 7 ‣ 4.1 Migrating Fhat Across Different Host CPUs ‣ 4 The Fhat Virtual Machine Architecture ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a> where <math id="S4.SS1.p1.1.m1.1" class="ltx_Math" alttext="n=1" display="inline"><semantics id="S4.SS1.p1.1.m1.1a"><mrow id="S4.SS1.p1.1.m1.1.1" xref="S4.SS1.p1.1.m1.1.1.cmml"><mi id="S4.SS1.p1.1.m1.1.1.2" xref="S4.SS1.p1.1.m1.1.1.2.cmml">n</mi><mo id="S4.SS1.p1.1.m1.1.1.1" xref="S4.SS1.p1.1.m1.1.1.1.cmml">=</mo><mn id="S4.SS1.p1.1.m1.1.1.3" xref="S4.SS1.p1.1.m1.1.1.3.cmml">1</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS1.p1.1.m1.1b"><apply id="S4.SS1.p1.1.m1.1.1.cmml" xref="S4.SS1.p1.1.m1.1.1"><eq id="S4.SS1.p1.1.m1.1.1.1.cmml" xref="S4.SS1.p1.1.m1.1.1.1"></eq><ci id="S4.SS1.p1.1.m1.1.1.2.cmml" xref="S4.SS1.p1.1.m1.1.1.2">𝑛</ci><cn type="integer" id="S4.SS1.p1.1.m1.1.1.3.cmml" xref="S4.SS1.p1.1.m1.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p1.1.m1.1c">n=1</annotation></semantics></math> refers to instruction 1.</p>
</div>
<figure id="S4.F7" class="ltx_figure"><img src="/html/0704.3395/assets/x7.png" id="S4.F7.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="215" height="148" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 7: </span>Migrating a Fhat execution across multiple host CPUs.</figcaption>
</figure>
<div id="S4.SS1.p2" class="ltx_para">
<p id="S4.SS1.p2.1" class="ltx_p">In principle, each CPU can execute one instruction and then halt. In this way, it is possible to migrate the Fhat RVM across different host CPU’s. Thus, if a portion of the Semantic Web is needed for a particular computation, it may be best to have the physical computer supporting that RDF sub-network host the Fhat RVM. Once the Fhat RVM has completed computing that particular RDF sub-network, it can halt and another CPU can pick up the process on a yet another area of the Semantic Web that needs computing by the Fhat RVM. In this model of computing, data doesn’t move to the process, the process moves to the data. This idea is diagrammed in Figure <a href="#S4.F8" title="Figure 8 ‣ 4.1 Migrating Fhat Across Different Host CPUs ‣ 4 The Fhat Virtual Machine Architecture ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a>, where both triple-store servers have Fhat process implementations.</p>
</div>
<figure id="S4.F8" class="ltx_figure"><img src="/html/0704.3395/assets/x8.png" id="S4.F8.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="269" height="152" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 8: </span>Migrating a Fhat state across different triple-stores.</figcaption>
</figure>
</section>
<section id="S4.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.2 </span>Fhat Reflection</h3>

<div id="S4.SS2.p1" class="ltx_para">
<p id="S4.SS2.p1.1" class="ltx_p">A Fhat RVM and the triple-code that it is executing are in the same address space and thus, can reference one another. It is the UUID address space of Neno/Fhat that makes it a unique programming environment in that Neno is not only a completely reflective language, but also that it removes the representational stack found in most other programming environments. Language reflection means that the program can modify itself during its execution. Many scripting languages and even Java (through the <span id="S4.SS2.p1.1.1" class="ltx_text ltx_font_typewriter">java.lang.reflect</span> package) support language reflection. However, not only does Neno/Fhat support language reflection, it also supports machine reflection. A Fhat can modify itself during its execution. There are no true boundaries between the various components of the computation. This idea is represented in Figure <a href="#S4.F9" title="Figure 9 ‣ 4.2 Fhat Reflection ‣ 4 The Fhat Virtual Machine Architecture ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">9</span></a>, where a Fhat RVM has its program counter (<span id="S4.SS2.p1.1.2" class="ltx_text ltx_font_typewriter">programLocation</span>) pointing to a <span id="S4.SS2.p1.1.3" class="ltx_text ltx_font_typewriter">Push</span> instruction. The <span id="S4.SS2.p1.1.4" class="ltx_text ltx_font_typewriter">Push</span> instruction is instructing Fhat to push a reference to itself on its operand stack. With a reference to the Fhat instance in the Fhat operand stack, Fhat can manipulate its own components. Thus, the Fhat RVM is executing triple-code that is manipulating itself.</p>
</div>
<figure id="S4.F9" class="ltx_figure"><img src="/html/0704.3395/assets/x9.png" id="S4.F9.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="322" height="102" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 9: </span>A Fhat processor can process itself.</figcaption>
</figure>
</section>
<section id="S4.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.3 </span>r-Fhat</h3>

<div id="S4.SS3.p1" class="ltx_para">
<p id="S4.SS3.p1.1" class="ltx_p">What has been presented thus far is a semi-hard implementation of Fhat. The semi-hard implementation explicitly encodes the state of a Fhat instance in RDF. While this has benefits such as fault tolerance due to virtual machine process failures, support for distributed computing in the form of processor migration, and support for machine-based evolutionary algorithms, it requires a large read/write overhead. Each instruction requires the virtual machine process to explicitly update the virtual machine state. A faster Fhat virtual machine can be engineered that does not explicitly encode the state of the machine in the RDF network. In such cases, the only read/write operations that occur are when an object is instantiated, destroyed, or a property manipulated. This faster Fhat is called reduced Fhat (r-Fhat). In r-Fhat, the operand stack, return stack, etc. are data structures in the implementing language. r-Fhat does not have an OWL machine architecture nor an RDF state.</p>
</div>
</section>
</section>
<section id="S5" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">5 </span>The Fhat Instruction Set</h2>

<div id="S5.p1" class="ltx_para">
<p id="S5.p1.1" class="ltx_p">In order for Neno software to run on a Fhat machine instance, it must be compiled to a Fhat OWL API that is compliant with the Fhat instruction set (the Fhat OWL API <span id="S5.p1.1.1" class="ltx_text ltx_font_typewriter">owl:imports</span> the Fhat instruction set ontology). A Fhat RVM uses the Fhat OWL API as a “blueprint” for constructing the instance-level representation of the RDF triple-code. It is the instance-level triple-code that the Fhat RVM “walks” when a program is executing.</p>
</div>
<section id="S5.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.1 </span>The <span id="S5.SS1.1.1" class="ltx_text ltx_font_typewriter">Method</span>
</h3>

<div id="S5.SS1.p1" class="ltx_para">
<p id="S5.SS1.p1.1" class="ltx_p">In Neno, the only process code that exists is that which is in a <span id="S5.SS1.p1.1.1" class="ltx_text ltx_font_typewriter">Method</span> <span id="S5.SS1.p1.1.2" class="ltx_text ltx_font_typewriter">Block</span>. Figure <a href="#S5.F10" title="Figure 10 ‣ 5.1 The Method ‣ 5 The Fhat Instruction Set ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">10</span></a> defines the OWL ontology of a <span id="S5.SS1.p1.1.3" class="ltx_text ltx_font_typewriter">Method</span>.</p>
</div>
<figure id="S5.F10" class="ltx_figure"><img src="/html/0704.3395/assets/x10.png" id="S5.F10.g1" class="ltx_graphics ltx_centering ltx_img_square" width="322" height="301" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 10: </span>The OWL <span id="S5.F10.2.1" class="ltx_text ltx_font_typewriter">Method</span> ontology.</figcaption>
</figure>
<div id="S5.SS1.p2" class="ltx_para">
<p id="S5.SS1.p2.1" class="ltx_p">A <span id="S5.SS1.p2.1.1" class="ltx_text ltx_font_typewriter">Method</span> has an <span id="S5.SS1.p2.1.2" class="ltx_text ltx_font_typewriter">ArgumentDescriptor</span> that is of <span id="S5.SS1.p2.1.3" class="ltx_text ltx_font_typewriter">rdfs:subClassOf</span> <span id="S5.SS1.p2.1.4" class="ltx_text ltx_font_typewriter">rdf:Seq</span> and a return descriptor that is of type <span id="S5.SS1.p2.1.5" class="ltx_text ltx_font_typewriter">rdfs:Resource</span>. The sequence of the <span id="S5.SS1.p2.1.6" class="ltx_text ltx_font_typewriter">ArgumentDescriptor</span> <span id="S5.SS1.p2.1.7" class="ltx_text ltx_font_typewriter">Argument</span> denotes the placement of the <span id="S5.SS1.p2.1.8" class="ltx_text ltx_font_typewriter">Method</span> parameter in the method declaration. For instance,
<span id="S5.SS1.p2.1.9" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S5.SS1.p2.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

xsd:integer exampleMethod(xsd:string n, Human h) { ... }

</pre>
<p id="S5.SS1.p2.3" class="ltx_p">would set the object of the <span id="S5.SS1.p2.3.1" class="ltx_text ltx_font_typewriter">hasReturnDescriptor</span> property to the URI <span id="S5.SS1.p2.3.2" class="ltx_text ltx_font_typewriter">xsd:integer</span> and the <span id="S5.SS1.p2.3.3" class="ltx_text ltx_font_typewriter">ArgumentDescriptor</span> to the <span id="S5.SS1.p2.3.4" class="ltx_text ltx_font_typewriter">Argument</span>s <span id="S5.SS1.p2.3.5" class="ltx_text ltx_font_typewriter">n</span> (<span id="S5.SS1.p2.3.6" class="ltx_text ltx_font_typewriter">rdf:_1</span>) and <span id="S5.SS1.p2.3.7" class="ltx_text ltx_font_typewriter">h</span> (<span id="S5.SS1.p2.3.8" class="ltx_text ltx_font_typewriter">rdf:_2</span>).</p>
</div>
<div id="S5.SS1.p3" class="ltx_para">
<p id="S5.SS1.p3.1" class="ltx_p">The <span id="S5.SS1.p3.1.1" class="ltx_text ltx_font_typewriter">hasHumanCode</span> property can be used, if desired, to point to the original human readable/writeable source code that describes that class and its methods. By using the <span id="S5.SS1.p3.1.2" class="ltx_text ltx_font_typewriter">hasHumanCode</span> property, it is possible for “in-network” or run-time compiling of source code. In principle, a Neno compiler can be written in Neno and be executed by a Fhat RVM. The Neno compiler can compile the representation that results from resolving the URI that is the value of the <span id="S5.SS1.p3.1.3" class="ltx_text ltx_font_typewriter">xsd:anyURI</span>.</p>
</div>
<section id="S5.SS1.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.1.1 </span>A <span id="S5.SS1.SSS1.1.1" class="ltx_text ltx_font_typewriter">Block</span> of Fhat Triple-Code</h4>

<div id="S5.SS1.SSS1.p1" class="ltx_para">
<p id="S5.SS1.SSS1.p1.1" class="ltx_p">A <span id="S5.SS1.SSS1.p1.1.1" class="ltx_text ltx_font_typewriter">Method</span> has a single <span id="S5.SS1.SSS1.p1.1.2" class="ltx_text ltx_font_typewriter">Block</span>. A <span id="S5.SS1.SSS1.p1.1.3" class="ltx_text ltx_font_typewriter">Block</span> is an <span id="S5.SS1.SSS1.p1.1.4" class="ltx_text ltx_font_typewriter">rdfs:subClassOf</span> <span id="S5.SS1.SSS1.p1.1.5" class="ltx_text ltx_font_typewriter">Instruction</span> and is composed of a sequence of <span id="S5.SS1.SSS1.p1.1.6" class="ltx_text ltx_font_typewriter">Instruction</span>s. The <span id="S5.SS1.SSS1.p1.1.7" class="ltx_text ltx_font_typewriter">Instruction</span> sequence is denoted by the <span id="S5.SS1.SSS1.p1.1.8" class="ltx_text ltx_font_typewriter">nextInst</span> property. The <span id="S5.SS1.SSS1.p1.1.9" class="ltx_text ltx_font_typewriter">Instruction</span> <span id="S5.SS1.SSS1.p1.1.10" class="ltx_text ltx_font_typewriter">rdf:type</span> is the “opcode” of the <span id="S5.SS1.SSS1.p1.1.11" class="ltx_text ltx_font_typewriter">Instruction</span>. The set of all <span id="S5.SS1.SSS1.p1.1.12" class="ltx_text ltx_font_typewriter">Instruction</span>s is the instruction set of the Fhat architecture. Figure <a href="#S5.F11" title="Figure 11 ‣ 5.1.1 A Block of Fhat Triple-Code ‣ 5.1 The Method ‣ 5 The Fhat Instruction Set ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">11</span></a> provides a collection of the super class <span id="S5.SS1.SSS1.p1.1.13" class="ltx_text ltx_font_typewriter">Instruction</span>s that can exist in a <span id="S5.SS1.SSS1.p1.1.14" class="ltx_text ltx_font_typewriter">Block</span> of code and their relationship to one another.</p>
</div>
<figure id="S5.F11" class="ltx_figure"><img src="/html/0704.3395/assets/x11.png" id="S5.F11.g1" class="ltx_graphics ltx_centering ltx_img_square" width="322" height="315" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 11: </span>The OWL ontology for a <span id="S5.F11.3.1" class="ltx_text ltx_font_typewriter">Block</span> of <span id="S5.F11.4.2" class="ltx_text ltx_font_typewriter">Instruction</span>s.</figcaption>
</figure>
<div id="S5.SS1.SSS1.p2" class="ltx_para">
<p id="S5.SS1.SSS1.p2.1" class="ltx_p">Examples of these super classes are itemized below.<span id="footnote14" class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">14</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">14</sup><span class="ltx_tag ltx_tag_note">14</span><span id="footnote14.1" class="ltx_text ltx_font_typewriter">Condition</span>s are unique in that they have a <span id="footnote14.2" class="ltx_text ltx_font_typewriter">trueInst</span> and a <span id="footnote14.3" class="ltx_text ltx_font_typewriter">falseInst</span> property. If the <span id="footnote14.4" class="ltx_text ltx_font_typewriter">Condition</span> is true, the next <span id="footnote14.5" class="ltx_text ltx_font_typewriter">Instruction</span> is the one pointed to by the <span id="footnote14.6" class="ltx_text ltx_font_typewriter">trueInst</span> property, else the next <span id="footnote14.7" class="ltx_text ltx_font_typewriter">Instruction</span> is one pointed to by the <span id="footnote14.8" class="ltx_text ltx_font_typewriter">falseInst</span> property.</span></span></span></p>
<ul id="S5.I1" class="ltx_itemize">
<li id="S5.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S5.I1.i1.p1" class="ltx_para">
<p id="S5.I1.i1.p1.1" class="ltx_p"><span id="S5.I1.i1.p1.1.1" class="ltx_text ltx_font_typewriter">Arithmetic</span>: <span id="S5.I1.i1.p1.1.2" class="ltx_text ltx_font_typewriter">Add</span>, <span id="S5.I1.i1.p1.1.3" class="ltx_text ltx_font_typewriter">Divide</span>, <span id="S5.I1.i1.p1.1.4" class="ltx_text ltx_font_typewriter">Multiply</span>, <span id="S5.I1.i1.p1.1.5" class="ltx_text ltx_font_typewriter">Not</span>, <span id="S5.I1.i1.p1.1.6" class="ltx_text ltx_font_typewriter">Subtract</span>.</p>
</div>
</li>
<li id="S5.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S5.I1.i2.p1" class="ltx_para">
<p id="S5.I1.i2.p1.1" class="ltx_p"><span id="S5.I1.i2.p1.1.1" class="ltx_text ltx_font_typewriter">Condition</span>: <span id="S5.I1.i2.p1.1.2" class="ltx_text ltx_font_typewriter">Equals</span>, <span id="S5.I1.i2.p1.1.3" class="ltx_text ltx_font_typewriter">GreaterThan</span>, <span id="S5.I1.i2.p1.1.4" class="ltx_text ltx_font_typewriter">GreaterThanEqual</span>, <span id="S5.I1.i2.p1.1.5" class="ltx_text ltx_font_typewriter">LessThan</span>, <span id="S5.I1.i2.p1.1.6" class="ltx_text ltx_font_typewriter">LessThanEqual</span>.</p>
</div>
</li>
<li id="S5.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S5.I1.i3.p1" class="ltx_para">
<p id="S5.I1.i3.p1.1" class="ltx_p"><span id="S5.I1.i3.p1.1.1" class="ltx_text ltx_font_typewriter">Setter</span>: <span id="S5.I1.i3.p1.1.2" class="ltx_text ltx_font_typewriter">NetQuery</span>, <span id="S5.I1.i3.p1.1.3" class="ltx_text ltx_font_typewriter">Set</span>, <span id="S5.I1.i3.p1.1.4" class="ltx_text ltx_font_typewriter">SetClear</span>, <span id="S5.I1.i3.p1.1.5" class="ltx_text ltx_font_typewriter">SetMinus</span>, <span id="S5.I1.i3.p1.1.6" class="ltx_text ltx_font_typewriter">SetPlus</span>, <span id="S5.I1.i3.p1.1.7" class="ltx_text ltx_font_typewriter">SetQuery</span>.</p>
</div>
</li>
<li id="S5.I1.i4" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S5.I1.i4.p1" class="ltx_para">
<p id="S5.I1.i4.p1.1" class="ltx_p"><span id="S5.I1.i4.p1.1.1" class="ltx_text ltx_font_typewriter">Invoke</span>: <span id="S5.I1.i4.p1.1.2" class="ltx_text ltx_font_typewriter">Construct</span>, <span id="S5.I1.i4.p1.1.3" class="ltx_text ltx_font_typewriter">Destruct</span>.</p>
</div>
</li>
</ul>
</div>
<div id="S5.SS1.SSS1.p3" class="ltx_para">
<p id="S5.SS1.SSS1.p3.1" class="ltx_p">The <span id="S5.SS1.SSS1.p3.1.1" class="ltx_text ltx_font_typewriter">Value</span> class has a set of subclasses. These subclasses are itemized below.</p>
<ul id="S5.I2" class="ltx_itemize">
<li id="S5.I2.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S5.I2.i1.p1" class="ltx_para">
<p id="S5.I2.i1.p1.1" class="ltx_p"><span id="S5.I2.i1.p1.1.1" class="ltx_text ltx_font_typewriter">Direct</span>: <span id="S5.I2.i1.p1.1.2" class="ltx_text ltx_font_typewriter">LocalDirect</span>, <span id="S5.I2.i1.p1.1.3" class="ltx_text ltx_font_typewriter">PopDirect</span>.</p>
</div>
</li>
<li id="S5.I2.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item">•</span> 
<div id="S5.I2.i2.p1" class="ltx_para">
<p id="S5.I2.i2.p1.1" class="ltx_p"><span id="S5.I2.i2.p1.1.1" class="ltx_text ltx_font_typewriter">Variable</span>: <span id="S5.I2.i2.p1.1.2" class="ltx_text ltx_font_typewriter">LocalVariable</span>, <span id="S5.I2.i2.p1.1.3" class="ltx_text ltx_font_typewriter">FieldVariable</span>, <span id="S5.I2.i2.p1.1.4" class="ltx_text ltx_font_typewriter">ObjectVariable</span>.</p>
</div>
</li>
</ul>
</div>
<div id="S5.SS1.SSS1.p4" class="ltx_para">
<p id="S5.SS1.SSS1.p4.1" class="ltx_p">When a Fhat instance enters a <span id="S5.SS1.SSS1.p4.1.1" class="ltx_text ltx_font_typewriter">Method</span> it creates a new <span id="S5.SS1.SSS1.p4.1.2" class="ltx_text ltx_font_typewriter">Frame</span>. When a <span id="S5.SS1.SSS1.p4.1.3" class="ltx_text ltx_font_typewriter">Variable</span> is declared, that <span id="S5.SS1.SSS1.p4.1.4" class="ltx_text ltx_font_typewriter">Variable</span> is specified in the <span id="S5.SS1.SSS1.p4.1.5" class="ltx_text ltx_font_typewriter">Frame</span> and according to the current <span id="S5.SS1.SSS1.p4.1.6" class="ltx_text ltx_font_typewriter">Block</span> of the <span id="S5.SS1.SSS1.p4.1.7" class="ltx_text ltx_font_typewriter">Fhat</span> instance as denoted by <span id="S5.SS1.SSS1.p4.1.8" class="ltx_text ltx_font_typewriter">Fhat</span>’s <span id="S5.SS1.SSS1.p4.1.9" class="ltx_text ltx_font_typewriter">blockTop</span> property. A <span id="S5.SS1.SSS1.p4.1.10" class="ltx_text ltx_font_typewriter">Block</span> is used for variable scoping. When Fhat leaves a <span id="S5.SS1.SSS1.p4.1.11" class="ltx_text ltx_font_typewriter">Block</span>, it destroys all the <span id="S5.SS1.SSS1.p4.1.12" class="ltx_text ltx_font_typewriter">FrameVariable</span>s in the current <span id="S5.SS1.SSS1.p4.1.13" class="ltx_text ltx_font_typewriter">Frame</span> that have that <span id="S5.SS1.SSS1.p4.1.14" class="ltx_text ltx_font_typewriter">Block</span> as their <span id="S5.SS1.SSS1.p4.1.15" class="ltx_text ltx_font_typewriter">fromBlock</span> property (refer to Figure <a href="#S4.F5" title="Figure 5 ‣ 4 The Fhat Virtual Machine Architecture ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>). However, entering a new <span id="S5.SS1.SSS1.p4.1.16" class="ltx_text ltx_font_typewriter">Block</span> is not exiting the old <span id="S5.SS1.SSS1.p4.1.17" class="ltx_text ltx_font_typewriter">Block</span>. Parent <span id="S5.SS1.SSS1.p4.1.18" class="ltx_text ltx_font_typewriter">Block</span> <span id="S5.SS1.SSS1.p4.1.19" class="ltx_text ltx_font_typewriter">FrameVariable</span>s can be accessed by child <span id="S5.SS1.SSS1.p4.1.20" class="ltx_text ltx_font_typewriter">Block</span>s. For instance, in the following Neno code fragment,
<span id="S5.SS1.SSS1.p4.1.21" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S5.SS1.SSS1.p4.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

xsd:integer x = "1"^^xsd:integer;
if(x &gt; 2) {
  xsd:integer y = x;
}
else{
  xsd:integer y = x;
}

</pre>
<p id="S5.SS1.SSS1.p4.3" class="ltx_p">the two <span id="S5.SS1.SSS1.p4.3.1" class="ltx_text ltx_font_typewriter">y</span> <span id="S5.SS1.SSS1.p4.3.2" class="ltx_text ltx_font_typewriter">Variable</span>s in the if and else <span id="S5.SS1.SSS1.p4.3.3" class="ltx_text ltx_font_typewriter">Block</span>s are two different <span id="S5.SS1.SSS1.p4.3.4" class="ltx_text ltx_font_typewriter">FrameVariables</span> since they are from different <span id="S5.SS1.SSS1.p4.3.5" class="ltx_text ltx_font_typewriter">Blocks</span>. Furthermore, note that both the if and else <span id="S5.SS1.SSS1.p4.3.6" class="ltx_text ltx_font_typewriter">Block</span>s can access the value of <span id="S5.SS1.SSS1.p4.3.7" class="ltx_text ltx_font_typewriter">x</span> since they are in the child <span id="S5.SS1.SSS1.p4.3.8" class="ltx_text ltx_font_typewriter">Block</span> of the <span id="S5.SS1.SSS1.p4.3.9" class="ltx_text ltx_font_typewriter">Block</span> declaring the variable <span id="S5.SS1.SSS1.p4.3.10" class="ltx_text ltx_font_typewriter">x</span>. When Fhat leaves a <span id="S5.SS1.SSS1.p4.3.11" class="ltx_text ltx_font_typewriter">Method</span> (i.e. returns), its <span id="S5.SS1.SSS1.p4.3.12" class="ltx_text ltx_font_typewriter">Frame</span> and its <span id="S5.SS1.SSS1.p4.3.13" class="ltx_text ltx_font_typewriter">FrameVariable</span>s are destroyed through dereferencing.</p>
</div>
</section>
</section>
<section id="S5.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">5.2 </span>A <span id="S5.SS2.1.1" class="ltx_text ltx_font_typewriter">Method</span> Instance</h3>

<div id="S5.SS2.p1" class="ltx_para">
<p id="S5.SS2.p1.2" class="ltx_p">There are two ways in which a <span id="S5.SS2.p1.2.3" class="ltx_text ltx_font_typewriter">Method</span> instance is handled by Fhat: global and local instance models. In the global instance model, when a new object is instantiated, its methods are also instantiated. However, if the instantiated <span id="S5.SS2.p1.2.4" class="ltx_text ltx_font_typewriter">Method</span> already exists in the RDF network, the newly created object points its <span id="S5.SS2.p1.2.5" class="ltx_text ltx_font_typewriter">hasMethod</span> property to a previously created <span id="S5.SS2.p1.2.6" class="ltx_text ltx_font_typewriter">Method</span> of the same <span id="S5.SS2.p1.2.7" class="ltx_text ltx_font_typewriter">hasMethodName</span> and UUID. Thus, only one instance of a <span id="S5.SS2.p1.2.8" class="ltx_text ltx_font_typewriter">Method</span> exists for all the objects of the same class type. While it is possible to have a unique <span id="S5.SS2.p1.2.9" class="ltx_text ltx_font_typewriter">Method</span> instance for each object, by supporting method reuse amongst objects, Fhat limits the growth (in terms of the number of triples) in the RDF network. Furthermore, this increases the speed of the Fhat RVM since it does not need to create a new <span id="S5.SS2.p1.2.10" class="ltx_text ltx_font_typewriter">Method</span> from the Fhat OWL API of that <span id="S5.SS2.p1.2.11" class="ltx_text ltx_font_typewriter">Method</span>. The global instance model is diagrammed in Figure <a href="#S5.F12" title="Figure 12 ‣ 5.2 A Method Instance ‣ 5 The Fhat Instruction Set ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">12</span></a>. To ensure global instances, the <span id="S5.SS2.p1.2.12" class="ltx_text ltx_font_typewriter">methodReuse</span> property of the <span id="S5.SS2.p1.2.13" class="ltx_text ltx_font_typewriter">Fhat</span> instance is set to <span id="S5.SS2.p1.2.2" class="ltx_text ltx_font_typewriter">"true"<sup id="S5.SS2.p1.2.2.1" class="ltx_sup"><span id="S5.SS2.p1.2.2.1.1" class="ltx_text ltx_font_serif">∧</span></sup><sup id="S5.SS2.p1.2.2.2" class="ltx_sup"><span id="S5.SS2.p1.2.2.2.1" class="ltx_text ltx_font_serif">∧</span></sup>xsd:boolean</span> (refer to Figure <a href="#S4.F5" title="Figure 5 ‣ 4 The Fhat Virtual Machine Architecture ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>).</p>
</div>
<figure id="S5.F12" class="ltx_figure"><img src="/html/0704.3395/assets/x12.png" id="S5.F12.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="322" height="228" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 12: </span>Multiple object’s of the same type will share the same <span id="S5.F12.2.1" class="ltx_text ltx_font_typewriter">Method</span> instance.</figcaption>
</figure>
<div id="S5.SS2.p2" class="ltx_para">
<p id="S5.SS2.p2.2" class="ltx_p">In the local instance model, the <span id="S5.SS2.p2.2.3" class="ltx_text ltx_font_typewriter">methodReuse</span> property of a <span id="S5.SS2.p2.2.4" class="ltx_text ltx_font_typewriter">Fhat</span> instance is set to <span id="S5.SS2.p2.2.2" class="ltx_text ltx_font_typewriter">"false"<sup id="S5.SS2.p2.2.2.1" class="ltx_sup"><span id="S5.SS2.p2.2.2.1.1" class="ltx_text ltx_font_serif">∧</span></sup><sup id="S5.SS2.p2.2.2.2" class="ltx_sup"><span id="S5.SS2.p2.2.2.2.1" class="ltx_text ltx_font_serif">∧</span></sup>xsd:boolean</span>. In such cases, a new <span id="S5.SS2.p2.2.5" class="ltx_text ltx_font_typewriter">Method</span> instance is created with each new instance of an <span id="S5.SS2.p2.2.6" class="ltx_text ltx_font_typewriter">owl:Thing</span>. The benefit of this model is that method reflection can occur on a per-object basis. If an object is to manipulate its <span id="S5.SS2.p2.2.7" class="ltx_text ltx_font_typewriter">Method</span> triple-code at run-time, it can do so without destroying the operation of its fellow <span id="S5.SS2.p2.2.8" class="ltx_text ltx_font_typewriter">owl:Thing</span>s. The drawback of the local instance model is triple-store “bloat” and an increase in the time required to instantiate an object relative to the global instance model. The local instance model is diagrammed in Figure <a href="#S5.F13" title="Figure 13 ‣ 5.2 A Method Instance ‣ 5 The Fhat Instruction Set ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">13</span></a>.</p>
</div>
<figure id="S5.F13" class="ltx_figure"><img src="/html/0704.3395/assets/x13.png" id="S5.F13.g1" class="ltx_graphics ltx_centering ltx_img_landscape" width="322" height="228" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 13: </span>Multiple object’s of the same type each have a unique <span id="S5.F13.2.1" class="ltx_text ltx_font_typewriter">Method</span> instance.</figcaption>
</figure>
<section id="S5.SS2.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection">5.2.1 </span>An Example <span id="S5.SS2.SSS1.1.1" class="ltx_text ltx_font_typewriter">Method</span> Instance</h4>

<div id="S5.SS2.SSS1.p1" class="ltx_para">
<p id="S5.SS2.SSS1.p1.1" class="ltx_p">Suppose the following code,
<span id="S5.SS2.SSS1.p1.1.1" class="ltx_text" style="font-size:80%;"></span></p>
<pre id="S5.SS2.SSS1.p1.2" class="ltx_verbatim ltx_font_typewriter" style="font-size:80%;">

owl:Thing demo:Human
{
  xsd:int example(xsd:string a) {
    if(a == "marko"^^xsd:string) {
      return "1"^^xsd:int;
    }
    else {
      return "2"^^xsd:int;
    }
  }
}

</pre>
</div>
<div id="S5.SS2.SSS1.p2" class="ltx_para">
<p id="S5.SS2.SSS1.p2.1" class="ltx_p">When this code is compiled, it compiles to a Fhat OWL API. When an instance of <span id="S5.SS2.SSS1.p2.1.1" class="ltx_text ltx_font_typewriter">demo:Human</span> is created, the Fhat RVM will start its journey at the URI <span id="S5.SS2.SSS1.p2.1.2" class="ltx_text ltx_font_typewriter">demo:Human</span> and move through the ontology creating instance UUID URIs for all the components of the <span id="S5.SS2.SSS1.p2.1.3" class="ltx_text ltx_font_typewriter">demo:Human</span> class. This includes, amongst its hard-coded properties, its <span id="S5.SS2.SSS1.p2.1.4" class="ltx_text ltx_font_typewriter">Method</span>s, their <span id="S5.SS2.SSS1.p2.1.5" class="ltx_text ltx_font_typewriter">Block</span>s, and their <span id="S5.SS2.SSS1.p2.1.6" class="ltx_text ltx_font_typewriter">Instruction</span>s. When the <span id="S5.SS2.SSS1.p2.1.7" class="ltx_text ltx_font_typewriter">demo:Human</span> class is instantiated, an instance will appear in the RDF network as diagrammed in Figure <a href="#S5.F14" title="Figure 14 ‣ 5.2.1 An Example Method Instance ‣ 5.2 A Method Instance ‣ 5 The Fhat Instruction Set ‣ General-Purpose Computing on a Semantic Network Substrate11footnote 1Rodriguez, M.A., “General-Purpose Computing on a Semantic Network Substrate,” Emergent Web Intelligence: Advanced Semantic Technologies, Advanced Information and Knowledge Processing series, eds. R. Chbeir, A. Hassanien, A. Abraham, and Y. Badr, Springer-Verlag, pages 57-104, ISBN:978-1-84996-076-2, June 2010." class="ltx_ref"><span class="ltx_text ltx_ref_tag">14</span></a>.</p>
</div>
<figure id="S5.F14" class="ltx_figure"><img src="/html/0704.3395/assets/x14.png" id="S5.F14.g1" class="ltx_graphics ltx_centering ltx_img_square" width="403" height="417" alt="Refer to caption">
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 14: </span>The RDF triple-code for the <span id="S5.F14.2.1" class="ltx_text ltx_font_typewriter">example(xsd:string)</span> method.</figcaption>
</figure>
</section>
</section>
</section>
<section id="S6" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">6 </span>Conclusion</h2>

<div id="S6.p1" class="ltx_para">
<p id="S6.p1.1" class="ltx_p">The primary drawback of the RVM is computing time because a virtual machine must not only read the RDF network to interpret the program instructions, it must also read/write to the RDF network to manipulate data (i.e. instance objects) in the RDF network. Moreover, the virtual machine must read and write to that sub-network of the RDF network that represents the virtual machine’s state (e.g. program counter, operand stack, etc.). In doing so, many read/write operations occur in order for the virtual machine to compute. However, much of this issue can be resolved through the use of r-Fhat.</p>
</div>
<div id="S6.p2" class="ltx_para">
<p id="S6.p2.1" class="ltx_p">Imagine a world where virtual machines are as easy to distribute as an HTML document (e.g. an RDF/XML encoding of the virtual machine sub-network). Given that a virtualized machine encodes its state in the RDF network, think about how RVMs can “move” between physical machines in mid-execution. There is complete hardware independence as no physical machine maintains a state representation. Physical machines compute the RVM by reading its program location, its operand stack, its heap, etc. and update those data structures. In such situations, a personal computer can be encoded in the RDF network and be accessed anywhere. Thus, the underlying physical machine is only a hardware shell for the more “personal” machine encoded in the RDF network. These ideas are analogous to those presented in ( ?).</p>
</div>
<div id="S6.p3" class="ltx_para">
<p id="S6.p3.1" class="ltx_p">In the RDF network, RVMs, APIs, and triple-code are “first-class” web entities. What happens when archiving services such as the Internet Archive, search engine caches, and digital libraries archive such RDF programs and “snap-shot” states of the executing RVMs ( ?, ?)? In theory, the state of computing world-wide, can be saved/archived and later retrieved to resume execution. The issues and novelties that archiving computations presents are many and are left to future work in this area.</p>
</div>
<div id="S6.p4" class="ltx_para">
<p id="S6.p4.1" class="ltx_p">Much of the Semantic Web effort is involved in the distribution of knowledge between organizational boundaries ( ?). This is perhaps the primary purpose of the ontology. In this respect, organizations of a similar domain should utilize shared ontologies in order to make their information useable between their respective organizations. Procedural encodings support the distribution of not only the knowledge models, but also the algorithms that can be applied to compute on those models. In a non-disjoint manner, data and code are easily exchanged between organizational boundaries ( ?).</p>
</div>
<div id="S6.p5" class="ltx_para">
<p id="S6.p5.1" class="ltx_p">Given that the RDF network is composed of triples and triples are composed of URIs and literals, the address space of any virtual machine in the RDF network is the set of all URIs and literals. Given that there are no bounds to the size of these resources, there are no realistic space limitations on the RVM. In other words, the amount of disk-space provided world-wide to support the Semantic Web is the actual memory constraints of this model. However, the success of this distributed computing paradigm relies on the consistent use of such standards as the Link Data specification ( ?). With further developments in Linked Data models and the RVM model of computing, the Semantic Web can be made to behave like a general-purpose computer.</p>
</div>
</section>
<section id="Sx1" class="ltx_section">
<h2 class="ltx_title ltx_title_section">Acknowledgments</h2>

<div id="Sx1.p1" class="ltx_para">
<p id="Sx1.p1.1" class="ltx_p">This research was made possible by a generous grant from the Andrew W. Mellon Foundation. Herbert Van de Sompel, Ryan Chute, and Johan Bollen all provided much insight during the development of these ideas.</p>
</div>
</section>
<section id="bib" class="ltx_bibliography">
<h2 class="ltx_title ltx_title_bibliography">References</h2>

<ul class="ltx_biblist">
<li id="bib.bibx1" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Aasman</span>
<span class="ltx_bibblock">
Aasman, J.

</span>
<span class="ltx_bibblock">(2006).

</span>
<span class="ltx_bibblock"><em id="bib.bibx1.1.1" class="ltx_emph ltx_font_italic">Allegro graph</em> (Tech. Rep. No. 1).

</span>
<span class="ltx_bibblock">Franz Incorporated.

</span>
</li>
<li id="bib.bibx2" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Aho, Sethi, &amp; Ullman</span>
<span class="ltx_bibblock">
Aho, A. W., Sethi, R., &amp; Ullman, J. D.

</span>
<span class="ltx_bibblock">(1986).

</span>
<span class="ltx_bibblock"><em id="bib.bibx2.1.1" class="ltx_emph ltx_font_italic">Compilers: Principles, techniques, and tools.</em>

</span>
<span class="ltx_bibblock">Addison-Wesley.

</span>
</li>
<li id="bib.bibx3" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Alesso &amp; Smith</span>
<span class="ltx_bibblock">
Alesso, H. P., &amp; Smith, C. F.

</span>
<span class="ltx_bibblock">(2005).

</span>
<span class="ltx_bibblock"><em id="bib.bibx3.1.1" class="ltx_emph ltx_font_italic">Developing Semantic Web services.</em>

</span>
<span class="ltx_bibblock">Wellesey, MA: A.K. Peters LTD.

</span>
</li>
<li id="bib.bibx4" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Beckett</span>
<span class="ltx_bibblock">
Beckett, D.

</span>
<span class="ltx_bibblock">(2001).

</span>
<span class="ltx_bibblock"><em id="bib.bibx4.1.1" class="ltx_emph ltx_font_italic">N-Triples</em> (Tech. Rep.).

</span>
<span class="ltx_bibblock">University of Bristol.

</span>
</li>
<li id="bib.bibx5" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Berners-Lee</span>
<span class="ltx_bibblock">
Berners-Lee, T.

</span>
<span class="ltx_bibblock">(1998).

</span>
<span class="ltx_bibblock"><em id="bib.bibx5.1.1" class="ltx_emph ltx_font_italic">Notation 3</em> (Tech. Rep.).

</span>
<span class="ltx_bibblock">World Wide Web Consortium.

</span>
</li>
<li id="bib.bibx6" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Berners-Lee</span>
<span class="ltx_bibblock">
Berners-Lee, T.

</span>
<span class="ltx_bibblock">(2006).

</span>
<span class="ltx_bibblock"><em id="bib.bibx6.1.1" class="ltx_emph ltx_font_italic">Linked data</em> (Tech. Rep.).

</span>
<span class="ltx_bibblock">World Wide Web Consortium.

</span>
</li>
<li id="bib.bibx7" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Berners-Lee, Fielding, Software, Masinter, &amp;
Systems</span>
<span class="ltx_bibblock">
Berners-Lee, T., Fielding, R. T., Software, D., Masinter, L., &amp;
Systems, A.

</span>
<span class="ltx_bibblock">(2005, January).

</span>
<span class="ltx_bibblock"><em id="bib.bibx7.1.1" class="ltx_emph ltx_font_italic">Uniform Resource Identifier (URI): Generic Syntax.</em>

</span>
</li>
<li id="bib.bibx8" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Biron &amp; Malhotra</span>
<span class="ltx_bibblock">
Biron, P. V., &amp; Malhotra, A.

</span>
<span class="ltx_bibblock">(2004).

</span>
<span class="ltx_bibblock"><em id="bib.bibx8.1.1" class="ltx_emph ltx_font_italic">XML schema part 2: Datatypes second edition</em> (Tech. Rep.).

</span>
<span class="ltx_bibblock">World Wide Web Consortium.

</span>
</li>
<li id="bib.bibx9" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Bray, Hollander, Layman, &amp; Tobin</span>
<span class="ltx_bibblock">
Bray, T., Hollander, D., Layman, A., &amp; Tobin, R.

</span>
<span class="ltx_bibblock">(2006).

</span>
<span class="ltx_bibblock"><em id="bib.bibx9.1.1" class="ltx_emph ltx_font_italic">Namespaces in XML 1.0</em> (Tech. Rep.).

</span>
<span class="ltx_bibblock">World Wide Web Consortium.

</span>
</li>
<li id="bib.bibx10" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Britton</span>
<span class="ltx_bibblock">
Britton, R.

</span>
<span class="ltx_bibblock">(2003).

</span>
<span class="ltx_bibblock"><em id="bib.bibx10.1.1" class="ltx_emph ltx_font_italic">MIPS assembly language programming.</em>

</span>
<span class="ltx_bibblock">Prentice Hall.

</span>
</li>
<li id="bib.bibx11" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Carroll &amp; Stickler</span>
<span class="ltx_bibblock">
Carroll, J. J., &amp; Stickler, P.

</span>
<span class="ltx_bibblock">(2004).

</span>
<span class="ltx_bibblock">RDF triples in XML.

</span>
<span class="ltx_bibblock">In <em id="bib.bibx11.1.1" class="ltx_emph ltx_font_italic">Extreme markup languages.</em>

</span>
<span class="ltx_bibblock">Montréal, Québec: IDEAlliance.

</span>
</li>
<li id="bib.bibx12" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Coelho &amp; Stanculescu</span>
<span class="ltx_bibblock">
Coelho, D., &amp; Stanculescu, A.

</span>
<span class="ltx_bibblock">(1988).

</span>
<span class="ltx_bibblock">A state-of-the-art VHDL simulator.

</span>
<span class="ltx_bibblock">In <em id="bib.bibx12.1.1" class="ltx_emph ltx_font_italic">Thirty-third IEEE computer society international
conference</em> (p. 320-323).

</span>
<span class="ltx_bibblock">San Francisco, CA.

</span>
</li>
<li id="bib.bibx13" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Craig</span>
<span class="ltx_bibblock">
Craig, I. D.

</span>
<span class="ltx_bibblock">(2005).

</span>
<span class="ltx_bibblock"><em id="bib.bibx13.1.1" class="ltx_emph ltx_font_italic">Virtual machines.</em>

</span>
<span class="ltx_bibblock">Springer.

</span>
</li>
<li id="bib.bibx14" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Davies, Fensel, &amp; Harmelen</span>
<span class="ltx_bibblock">
Davies, J., Fensel, D., &amp; Harmelen, F. van.

</span>
<span class="ltx_bibblock">(2003).

</span>
<span class="ltx_bibblock"><em id="bib.bibx14.1.1" class="ltx_emph ltx_font_italic">Towards the semantic web: Ontology-driven knowledge
management.</em>

</span>
<span class="ltx_bibblock">Wiley.

</span>
</li>
<li id="bib.bibx15" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Eckel</span>
<span class="ltx_bibblock">
Eckel, B.

</span>
<span class="ltx_bibblock">(2002).

</span>
<span class="ltx_bibblock"><em id="bib.bibx15.1.1" class="ltx_emph ltx_font_italic">Thinking in Java.</em>

</span>
<span class="ltx_bibblock">Prentice Hall.

</span>
</li>
<li id="bib.bibx16" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Fensel</span>
<span class="ltx_bibblock">
Fensel, D.

</span>
<span class="ltx_bibblock">(2004).

</span>
<span class="ltx_bibblock">Triple-space computing: Semantic web services based on
pesistent publication of information.

</span>
<span class="ltx_bibblock">In <em id="bib.bibx16.1.1" class="ltx_emph ltx_font_italic">Proceedings of the International Conference on
Intelligence in Communication Systems</em> (pp. 43–53).

</span>
<span class="ltx_bibblock">Bangkok, Thailand.

</span>
</li>
<li id="bib.bibx17" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Fensel, Hendler, Lieberman, &amp;
Wahlster</span>
<span class="ltx_bibblock">
Fensel, D., Hendler, J. A., Lieberman, H., &amp; Wahlster, W. (Eds.).

</span>
<span class="ltx_bibblock">(2003).

</span>
<span class="ltx_bibblock"><em id="bib.bibx17.1.1" class="ltx_emph ltx_font_italic">Spinning the Semantic Web: Bringing the World Wide
Web to its full potential.</em>

</span>
<span class="ltx_bibblock">MIT Press.

</span>
</li>
<li id="bib.bibx18" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Hennessy &amp; Patterson</span>
<span class="ltx_bibblock">
Hennessy, J. L., &amp; Patterson, D. A.

</span>
<span class="ltx_bibblock">(2002).

</span>
<span class="ltx_bibblock"><em id="bib.bibx18.1.1" class="ltx_emph ltx_font_italic">Computer architecture: A quantitative approach.</em>

</span>
<span class="ltx_bibblock">Morgan Kaufmann.

</span>
</li>
<li id="bib.bibx19" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Kifer, Lausen, &amp; Wu.</span>
<span class="ltx_bibblock">
Kifer, M., Lausen, G., &amp; Wu., J.

</span>
<span class="ltx_bibblock">(1995).

</span>
<span class="ltx_bibblock">Logical foundations of object-oriented and logical
foundations of object-oriented and.

</span>
<span class="ltx_bibblock"><em id="bib.bibx19.1.1" class="ltx_emph ltx_font_italic">Journal of the ACM</em>, <em id="bib.bibx19.2.2" class="ltx_emph ltx_font_italic">42</em>(4), 741-843.

</span>
</li>
<li id="bib.bibx20" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Koide &amp; Kawamura</span>
<span class="ltx_bibblock">
Koide, S., &amp; Kawamura, M.

</span>
<span class="ltx_bibblock">(2004).

</span>
<span class="ltx_bibblock">SWCLOS: A Semantic Web processor on Common Lisp
object system.

</span>
<span class="ltx_bibblock">In <em id="bib.bibx20.1.1" class="ltx_emph ltx_font_italic">Proceedings of the International Semantic Web
Conference.</em>

</span>
<span class="ltx_bibblock">Hiroshima, Japan.

</span>
</li>
<li id="bib.bibx21" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Leach</span>
<span class="ltx_bibblock">
Leach, P. J.

</span>
<span class="ltx_bibblock">(2005).

</span>
<span class="ltx_bibblock"><em id="bib.bibx21.1.1" class="ltx_emph ltx_font_italic">A Universally Unique IDentifier (UUID) URN
Namespace</em> (Tech. Rep.).

</span>
<span class="ltx_bibblock">Network Working Group.

</span>
</li>
<li id="bib.bibx22" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Lee</span>
<span class="ltx_bibblock">
Lee, R.

</span>
<span class="ltx_bibblock">(2004).

</span>
<span class="ltx_bibblock"><em id="bib.bibx22.1.1" class="ltx_emph ltx_font_italic">Scalability report on triple store applications</em> (Tech. Rep.).

</span>
<span class="ltx_bibblock">Massachusetts Institute of Technology.

</span>
</li>
<li id="bib.bibx23" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Lindholm &amp; Yellin</span>
<span class="ltx_bibblock">
Lindholm, T., &amp; Yellin, F.

</span>
<span class="ltx_bibblock">(1999).

</span>
<span class="ltx_bibblock"><em id="bib.bibx23.1.1" class="ltx_emph ltx_font_italic">The Java virtual machine specification.</em>

</span>
<span class="ltx_bibblock">Addison-Wesley.

</span>
</li>
<li id="bib.bibx24" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Lorie</span>
<span class="ltx_bibblock">
Lorie, R. A.

</span>
<span class="ltx_bibblock">(2001).

</span>
<span class="ltx_bibblock">Long term preservation of digital information.

</span>
<span class="ltx_bibblock">In <em id="bib.bibx24.1.1" class="ltx_emph ltx_font_italic">Proceedings of the 1st ACM/IEEE-CS joint
conference on digital libraries</em> (pp. 346–352).

</span>
<span class="ltx_bibblock">New York, NY, USA: ACM Press.

</span>
</li>
<li id="bib.bibx25" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Louden</span>
<span class="ltx_bibblock">
Louden, K. C.

</span>
<span class="ltx_bibblock">(2003).

</span>
<span class="ltx_bibblock"><em id="bib.bibx25.1.1" class="ltx_emph ltx_font_italic">Progamming languages: Principles and practice.</em>

</span>
<span class="ltx_bibblock">Brooks/Cole - Thomson Learning.

</span>
</li>
<li id="bib.bibx26" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Manola &amp; Miller</span>
<span class="ltx_bibblock">
Manola, F., &amp; Miller, E.

</span>
<span class="ltx_bibblock">(2004, February).

</span>
<span class="ltx_bibblock"><em id="bib.bibx26.1.1" class="ltx_emph ltx_font_italic">RDF primer: W3C recommendation.</em>

</span>
</li>
<li id="bib.bibx27" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Martin et al.</span>
<span class="ltx_bibblock">
Martin, D., Burstein, M., Hobbs, J., Lassila, O., McDermott, D., McIlraith, S.,
Narayanan, S., Paolucci, M., Parsia, B., Payne, T., Sirin, E., Srinivasan,
N., &amp; Sycara, K.

</span>
<span class="ltx_bibblock">(2004).

</span>
<span class="ltx_bibblock"><em id="bib.bibx27.1.1" class="ltx_emph ltx_font_italic">OWL-S: Semantic markup for web services</em> (Tech. Rep.).

</span>
<span class="ltx_bibblock">World Wide Web Consortium.

</span>
</li>
<li id="bib.bibx28" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">McGuinness &amp; Harmelen</span>
<span class="ltx_bibblock">
McGuinness, D. L., &amp; Harmelen, F. van.

</span>
<span class="ltx_bibblock">(2004, February).

</span>
<span class="ltx_bibblock"><em id="bib.bibx28.1.1" class="ltx_emph ltx_font_italic">OWL web ontology language overview.</em>

</span>
</li>
<li id="bib.bibx29" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Nelson, McCown, Smith, &amp; Klein</span>
<span class="ltx_bibblock">
Nelson, M. L., McCown, F., Smith, J., &amp; Klein, M.

</span>
<span class="ltx_bibblock">(2007).

</span>
<span class="ltx_bibblock">Using the web infrastructure to preserve web pages.

</span>
<span class="ltx_bibblock"><em id="bib.bibx29.1.1" class="ltx_emph ltx_font_italic">International Journal on Digital Libraries</em>.

</span>
</li>
<li id="bib.bibx30" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Oren, Delbru, Gerke, Haller, &amp; Decker</span>
<span class="ltx_bibblock">
Oren, E., Delbru, R., Gerke, S., Haller, A., &amp; Decker, S.

</span>
<span class="ltx_bibblock">(2007).

</span>
<span class="ltx_bibblock">ActiveRDF: Object-oriented semantic web programming.

</span>
<span class="ltx_bibblock">In <em id="bib.bibx30.1.1" class="ltx_emph ltx_font_italic">Proceedings of the International World Wide Web
Conference WWW07.</em>

</span>
<span class="ltx_bibblock">Banff, Canada.

</span>
</li>
<li id="bib.bibx31" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Prud’hommeaux &amp; Seaborne</span>
<span class="ltx_bibblock">
Prud’hommeaux, E., &amp; Seaborne, A.

</span>
<span class="ltx_bibblock">(2004).

</span>
<span class="ltx_bibblock"><em id="bib.bibx31.1.1" class="ltx_emph ltx_font_italic">SPARQL query language for RDF</em> (Tech. Rep.).

</span>
<span class="ltx_bibblock">World Wide Web Consortium.

</span>
</li>
<li id="bib.bibx32" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Rodriguez, Watkins, Bollen, &amp;
Gershenson</span>
<span class="ltx_bibblock">
Rodriguez, M. A., Watkins, J. H., Bollen, J., &amp; Gershenson, C.

</span>
<span class="ltx_bibblock">(2007).

</span>
<span class="ltx_bibblock">Using RDF to model the structure and process of
systems.

</span>
<span class="ltx_bibblock"><em id="bib.bibx32.1.1" class="ltx_emph ltx_font_italic">InterJournal of Complex Systems</em>, <em id="bib.bibx32.2.2" class="ltx_emph ltx_font_italic">2131</em>.

</span>
</li>
<li id="bib.bibx33" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Satyanarayanan et al.</span>
<span class="ltx_bibblock">
Satyanarayanan, M., Gilbert, B., Toups, M., Tolia, N., Surie, A., O’Hallaron,
D. R., Wolbach, A., Harkes, J., Perrig, A., Farber, D. J., Kozuch, M. A.,
Helfrich, C. J., Nath, P., &amp; Lagar-Cavilla, H. A.

</span>
<span class="ltx_bibblock">(2007).

</span>
<span class="ltx_bibblock">Pervasive personal computing in an internet suspend/resume
system.

</span>
<span class="ltx_bibblock"><em id="bib.bibx33.1.1" class="ltx_emph ltx_font_italic">IEEE Internet Computing</em>, <em id="bib.bibx33.2.2" class="ltx_emph ltx_font_italic">11</em>(2), 16-25.

</span>
</li>
<li id="bib.bibx34" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Seaborne &amp; Manjunath</span>
<span class="ltx_bibblock">
Seaborne, A., &amp; Manjunath, G.

</span>
<span class="ltx_bibblock">(2007).

</span>
<span class="ltx_bibblock"><em id="bib.bibx34.1.1" class="ltx_emph ltx_font_italic">SPARQL/Update: A language for updating RDF graphs</em> (Tech. Rep.).

</span>
<span class="ltx_bibblock">Hewlett-Packard.

</span>
</li>
<li id="bib.bibx35" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Sebesta</span>
<span class="ltx_bibblock">
Sebesta, R. W.

</span>
<span class="ltx_bibblock">(2005).

</span>
<span class="ltx_bibblock"><em id="bib.bibx35.1.1" class="ltx_emph ltx_font_italic">Concepts of programming languages.</em>

</span>
<span class="ltx_bibblock">Addison-Wesley.

</span>
</li>
<li id="bib.bibx36" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Shinavier</span>
<span class="ltx_bibblock">
Shinavier, J.

</span>
<span class="ltx_bibblock">(2007).

</span>
<span class="ltx_bibblock">Functional programs as Linked Data.

</span>
<span class="ltx_bibblock">In <em id="bib.bibx36.1.1" class="ltx_emph ltx_font_italic">3rd Workshop on Scripting for the Semantic Web.</em>

</span>
<span class="ltx_bibblock">Innsbruck, Austria.

</span>
</li>
<li id="bib.bibx37" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Sowa</span>
<span class="ltx_bibblock">
Sowa, J. F.

</span>
<span class="ltx_bibblock">(1991).

</span>
<span class="ltx_bibblock"><em id="bib.bibx37.1.1" class="ltx_emph ltx_font_italic">Principles of semantic networks: Explorations in the
representation of knowledge.</em>

</span>
<span class="ltx_bibblock">San Mateo, CA: Morgan Kaufmann.

</span>
</li>
<li id="bib.bibx38" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Sowa</span>
<span class="ltx_bibblock">
Sowa, J. F.

</span>
<span class="ltx_bibblock">(1999).

</span>
<span class="ltx_bibblock"><em id="bib.bibx38.1.1" class="ltx_emph ltx_font_italic">Knowledge representation: Logical, philosophical, and
computational foundations.</em>

</span>
<span class="ltx_bibblock">Course Technology.

</span>
</li>
<li id="bib.bibx39" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Turing</span>
<span class="ltx_bibblock">
Turing, A. M.

</span>
<span class="ltx_bibblock">(1937).

</span>
<span class="ltx_bibblock">On computable numbers, with an application to the
entscheidungsproblem.

</span>
<span class="ltx_bibblock"><em id="bib.bibx39.1.1" class="ltx_emph ltx_font_italic">Proceedings of the London Mathematical Society</em>, <em id="bib.bibx39.2.2" class="ltx_emph ltx_font_italic">42</em>(2),
230–265.

</span>
</li>
<li id="bib.bibx40" class="ltx_bibitem">
<span class="ltx_tag ltx_role_refnum ltx_tag_bibitem">Wang et al.</span>
<span class="ltx_bibblock">
Wang, H. H., Noy, N., Rector, A., Musen, M., Redmond, T., Rubin, D., Tu, S.,
Tudorache, T., Drummond, N., Horridge, M., &amp; Sedenberg, J.

</span>
<span class="ltx_bibblock">(2007).

</span>
<span class="ltx_bibblock">Frames and OWL side by side.

</span>
<span class="ltx_bibblock">In <em id="bib.bibx40.1.1" class="ltx_emph ltx_font_italic">10th International Protégé Conference.</em>

</span>
<span class="ltx_bibblock">Budapest, Hungary.

</span>
</li>
</ul>
</section>
</article>
</div>
<div class="ar5iv-footer"><a href="/html/0704.3394" class="ar5iv-nav-button ar5iv-nav-button-prev">◄</a>
    <a class="ar5iv-home-button" href="/"><img height="40" alt="ar5iv homepage" src="/assets/ar5iv.png"></a>
    <a href="/feeling_lucky" class="ar5iv-text-button">Feeling<br>lucky?</a>
    <a href="/log/0704.3395" class="ar5iv-text-button ar5iv-severity-warning">Conversion<br>report</a>
    <a class="ar5iv-text-button" target="_blank" href="https://github.com/dginev/ar5iv/issues/new?template=improve-article--arxiv-id-.md&title=Improve+article+0704.3395">Report<br>an issue</a>
    <a href="https://arxiv.org/abs/0704.3395" class="ar5iv-text-button arxiv-ui-theme">View&nbsp;original<br>on&nbsp;arXiv</a><a href="/html/0704.3396" class="ar5iv-nav-button ar5iv-nav-button-next">►</a>
</div><footer class="ltx_page_footer">
<a class="ar5iv-toggle-color-scheme" href="javascript:toggleColorScheme()" title="Toggle ar5iv color scheme"><span class="color-scheme-icon"></span></a>
<a class="ar5iv-footer-button" href="https://arxiv.org/help/license" target="_blank">Copyright</a>
<a class="ar5iv-footer-button" href="https://arxiv.org/help/policies/privacy_policy" target="_blank">Privacy Policy</a>

<div class="ltx_page_logo">Generated  on Tue Mar 19 20:44:35 2024 by <a target="_blank" href="http://dlmf.nist.gov/LaTeXML/" class="ltx_LaTeXML_logo"><span style="letter-spacing:-0.2em; margin-right:0.1em;">L<span class="ltx_font_smallcaps" style="position:relative; bottom:2.2pt;">a</span>T<span class="ltx_font_smallcaps" style="font-size:120%;position:relative; bottom:-0.2ex;">e</span></span><span style="font-size:90%; position:relative; bottom:-0.2ex;">XML</span><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="Mascot Sammy"></a>
</div></footer>
</div>

    <script>
      var canMathML = typeof(MathMLElement) == "function";
      if (!canMathML) {
        var body = document.querySelector("body");
        body.firstElementChild.setAttribute('style', 'opacity: 0;');
        var loading = document.createElement("div");
        loading.setAttribute("id", "mathjax-loading-spinner");
        var message = document.createElement("div");
        message.setAttribute("id", "mathjax-loading-message");
        message.innerText = "Typesetting Equations...";
        body.prepend(loading);
        body.prepend(message);

        var el = document.createElement("script");
        el.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js";
        document.querySelector("head").appendChild(el);

        window.MathJax = {
          startup: {
            pageReady: () => {
              return MathJax.startup.defaultPageReady().then(() => {
                body.removeChild(loading);
                body.removeChild(message);
                body.firstElementChild.removeAttribute('style');
              }); } } };
      }
    </script>
    <script>
    // Auxiliary function, building the preview feature when
    // an inline citation is clicked
    function clicked_cite(e) {
      e.preventDefault();
      let cite = this.closest('.ltx_cite');
      let next = cite.nextSibling;
      if (next && next.nodeType == Node.ELEMENT_NODE && next.getAttribute('class') == "ar5iv-bibitem-preview") {
        next.remove();
        return; }
      // Before adding a preview modal,
      // cleanup older previews, in case they're still open
      document.querySelectorAll('span.ar5iv-bibitem-preview').forEach(function(node) {
        node.remove();
      })

      // Create the preview
      preview = document.createElement('span');
      preview.setAttribute('class','ar5iv-bibitem-preview');
      let target = document.getElementById(this.getAttribute('href').slice(1));
      target.childNodes.forEach(function (child) {
        preview.append(child.cloneNode(true));
      });
      let close_x = document.createElement('button');
      close_x.setAttribute("aria-label","Close modal for bibliography item preview");
      close_x.textContent = "×";
      close_x.setAttribute('class', 'ar5iv-button-close-preview');
      close_x.setAttribute('onclick','this.parentNode.remove()');
      preview.append(close_x);
      preview.querySelectorAll('.ltx_tag_bibitem').forEach(function(node) {
        node.remove();
      });
      cite.parentNode.insertBefore(preview, cite.nextSibling);
      return;
    }
    // Global Document initialization:
    // - assign the preview feature to all inline citation links
    document.querySelectorAll(".ltx_cite .ltx_ref").forEach(function (link) {
      link.addEventListener("click", clicked_cite);
    });
    </script>
    </body>
</html>
